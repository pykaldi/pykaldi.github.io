

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>kaldi.fstext._api &mdash; PyKaldi 0.0.9 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato" type="text/css" />
  
    <link rel="stylesheet" href="../../../_static/pykaldi-theme.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="PyKaldi 0.0.9 documentation" href="../../../index.html"/>
        <link rel="up" title="kaldi.fstext" href="../fstext.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/pykaldi-logo-light.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user/about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/install.html">Installation</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/conv.html">Coding Conventions</a></li>
</ul>
<p class="caption"><span class="caption-text">API Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.base.html">kaldi.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.chain.html">kaldi.chain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.cudamatrix.html">kaldi.cudamatrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.decoder.html">kaldi.decoder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.feat.html">kaldi.feat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.fstext.html">kaldi.fstext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.gmm.html">kaldi.gmm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.hmm.html">kaldi.hmm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.itf.html">kaldi.itf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.ivector.html">kaldi.ivector</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.kws.html">kaldi.kws</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.lat.html">kaldi.lat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.lm.html">kaldi.lm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.matrix.html">kaldi.matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.nnet3.html">kaldi.nnet3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.online2.html">kaldi.online2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.rnnlm.html">kaldi.rnnlm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.sgmm2.html">kaldi.sgmm2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.tfrnnlm.html">kaldi.tfrnnlm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.transform.html">kaldi.transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.tree.html">kaldi.tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/kaldi.util.html">kaldi.util</a></li>
</ul>

            
          
    <p class="caption"><span class="caption-text">Other</span></p>
    <ul>
    <li class="toctree-l1"><a href="../../../genindex.html">Index</a></li>
    </ul>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PyKaldi</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../fstext.html">kaldi.fstext</a> &raquo;</li>
        
      <li>kaldi.fstext._api</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for kaldi.fstext._api</h1><div class="highlight"><pre>
<span></span><span class="c1"># The Python API was largely adapted from the official OpenFst Python wrapper.</span>
<span class="c1"># See www.openfst.org for additional documentation.</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">..base.io</span> <span class="k">import</span> <span class="n">ofstream</span><span class="p">,</span> <span class="n">ostringstream</span><span class="p">,</span> <span class="n">stringstream</span>

<span class="c1"># Constants</span>
<span class="kn">import</span> <span class="nn">_getters</span>            <span class="c1"># Relative/absolute import of _getters and</span>
<span class="kn">from</span> <span class="nn">_weight</span> <span class="k">import</span> <span class="n">DELTA</span>  <span class="c1"># _weight modules is buggy in Python 3.</span>
<span class="kn">from</span> <span class="nn">.properties</span> <span class="k">import</span> <span class="n">ACCEPTOR</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">,</span> <span class="n">EXPANDED</span><span class="p">,</span> <span class="n">WEIGHTED</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">NO_STATE_ID</span>

<span class="n">INT32_MAX</span> <span class="o">=</span> <span class="mi">2147483647</span>


<span class="c1"># Helpers</span>

<span class="k">def</span> <span class="nf">_get_weight_or_default</span><span class="p">(</span><span class="n">weight_factory</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_one</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts weight to an instance of the weight type.</span>

<span class="sd">    If weight is None, the weight is set to:</span>
<span class="sd">    * semiring one when default_one is True,</span>
<span class="sd">    * semiring zero when default_one is False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">weight_factory</span><span class="o">.</span><span class="n">one</span><span class="p">()</span> <span class="k">if</span> <span class="n">default_one</span> <span class="k">else</span> <span class="n">weight_factory</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">weight_factory</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">weight</span>
    <span class="k">return</span> <span class="n">weight_factory</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>


<span class="c1"># Arc API</span>

<span class="k">class</span> <span class="nc">_ArcBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the Python API for Arc types.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ilabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">olabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nextstate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attributes of the arc can be accessed and mutated.</span>

<span class="sd">        Args:</span>
<span class="sd">            ilabel (int): The input label.</span>
<span class="sd">            olabel (int): The output label.</span>
<span class="sd">            weight: The arc weight.</span>
<span class="sd">            nextstate (int): The destination state for the arc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_ArcBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ilabel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ilabel</span> <span class="o">=</span> <span class="n">ilabel</span>
        <span class="k">if</span> <span class="n">olabel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">olabel</span> <span class="o">=</span> <span class="n">olabel</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span>
        <span class="k">if</span> <span class="n">nextstate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nextstate</span> <span class="o">=</span> <span class="n">nextstate</span>


<span class="c1"># Encoder API</span>

<span class="k">class</span> <span class="nc">_EncodeMapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Arc encoder.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encode_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">encode_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">encode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class provides an object which can be used to encode or decode FST</span>
<span class="sd">        arcs. This is most useful to convert an FST to an unweighted acceptor,</span>
<span class="sd">        on which some FST operations are more efficient, and then decoding the</span>
<span class="sd">        FST afterwards.</span>

<span class="sd">        To use an instance of this class to encode or decode a mutable FST, pass</span>
<span class="sd">        it as the first argument to the FST instance methods `encode` and</span>
<span class="sd">        `decode`. Alternatively, an instance of this class can be used as a</span>
<span class="sd">        callable to encode/decode arcs.</span>

<span class="sd">        Args:</span>
<span class="sd">            encode_labels (bool): Should labels be encoded?</span>
<span class="sd">            encode_weights (bool): Should weights be encoded?</span>
<span class="sd">            encode (bool): Encode or decode?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetEncodeFlags</span><span class="p">(</span><span class="n">encode_labels</span><span class="p">,</span> <span class="n">encode_weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">encode</span><span class="p">:</span>
            <span class="n">encoder_type</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">EncodeType</span><span class="o">.</span><span class="n">ENCODE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">encoder_type</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">EncodeType</span><span class="o">.</span><span class="n">DECODE</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_EncodeMapper</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">encoder_type</span><span class="p">)</span>


<span class="c1"># Compiler API</span>

<span class="k">class</span> <span class="nc">_FstCompiler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class used to compile FSTs from strings.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">osymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ssymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">acceptor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_isymbols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_osymbols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">keep_state_numbering</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_negative_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class is used to compile FSTs specified using the AT&amp;T FSM library</span>
<span class="sd">        format described here:</span>

<span class="sd">        http://web.eecs.umich.edu/~radev/NLP-fall2015/resources/fsm_archive/fsm.5.html</span>

<span class="sd">        This is the same format used by the `fstcompile` executable.</span>

<span class="sd">        FstCompiler options (symbol tables, etc.) are set at construction time::</span>

<span class="sd">            compiler = FstCompiler(isymbols=ascii_syms, osymbols=ascii_syms)</span>

<span class="sd">        Once constructed, FstCompiler instances behave like a file handle opened</span>
<span class="sd">        for writing::</span>

<span class="sd">            # /ba+/</span>
<span class="sd">            print(&quot;0 1 50 50&quot;, file=compiler)</span>
<span class="sd">            print(&quot;1 2 49 49&quot;, file=compiler)</span>
<span class="sd">            print(&quot;2 2 49 49&quot;, file=compiler)</span>
<span class="sd">            print(&quot;2&quot;, file=compiler)</span>

<span class="sd">        The `compile` method returns an actual FST instance::</span>

<span class="sd">            sheep_machine = compiler.compile()</span>

<span class="sd">        Compilation flushes the internal buffer, so the compiler instance can be</span>
<span class="sd">        reused to compile new machines with the same symbol tables, etc.</span>

<span class="sd">        Args:</span>
<span class="sd">            isymbols: An optional SymbolTable used to label input symbols.</span>
<span class="sd">            osymbols: An optional SymbolTable used to label output symbols.</span>
<span class="sd">            ssymbols: An optional SymbolTable used to label states.</span>
<span class="sd">            acceptor: Should the FST be rendered in acceptor format if possible?</span>
<span class="sd">            keep_isymbols: Should the input symbol table be stored in the FST?</span>
<span class="sd">            keep_osymbols: Should the output symbol table be stored in the FST?</span>
<span class="sd">            keep_state_numbering: Should the state numbering be preserved?</span>
<span class="sd">            allow_negative_labels: Should negative labels be allowed? (Not</span>
<span class="sd">                recommended; may cause conflicts).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_strbuf</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_isymbols</span> <span class="o">=</span> <span class="n">isymbols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_osymbols</span> <span class="o">=</span> <span class="n">osymbols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssymbols</span> <span class="o">=</span> <span class="n">ssymbols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_acceptor</span> <span class="o">=</span> <span class="n">acceptor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keep_isymbols</span> <span class="o">=</span> <span class="n">keep_isymbols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keep_osymbols</span> <span class="o">=</span> <span class="n">keep_osymbols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keep_state_numbering</span> <span class="o">=</span> <span class="n">keep_state_numbering</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allow_negative_labels</span> <span class="o">=</span> <span class="n">allow_negative_labels</span>

    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compiles the FST in the string buffer.</span>

<span class="sd">        This method compiles the FST and returns the resulting machine.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The FST described by the string buffer.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: Compilation failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sstrm</span> <span class="o">=</span> <span class="n">stringstream</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strbuf</span><span class="p">)</span>
        <span class="n">compiler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compiler_type</span><span class="p">(</span>
            <span class="n">sstrm</span><span class="p">,</span> <span class="s2">&quot;compile&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_isymbols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_osymbols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssymbols</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acceptor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keep_isymbols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keep_osymbols</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keep_state_numbering</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allow_negative_labels</span><span class="p">)</span>
        <span class="n">ofst</span> <span class="o">=</span> <span class="n">compiler</span><span class="o">.</span><span class="n">fst</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strbuf</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ofst</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Compilation failed&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ofst</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes a string into the compiler string buffer.</span>

<span class="sd">        This method adds a line to the compiler string buffer. It can also be</span>
<span class="sd">        invoked with a print call, like so::</span>

<span class="sd">            compiler = FstCompiler()</span>
<span class="sd">            print(&quot;0 0 49 49&quot;, file=compiler)</span>
<span class="sd">            print(&quot;0&quot;, file=compiler)</span>

<span class="sd">        Args:</span>
<span class="sd">            expression: A string expression to add to compiler string buffer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strbuf</span> <span class="o">+=</span> <span class="n">expression</span>


<span class="c1"># Drawer API</span>

<span class="k">class</span> <span class="nc">_FstDrawer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the Python API for FST drawers.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fst</span><span class="p">,</span> <span class="n">isyms</span><span class="p">,</span> <span class="n">osyms</span><span class="p">,</span> <span class="n">ssyms</span><span class="p">,</span> <span class="n">accep</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span>
                 <span class="n">portrait</span><span class="p">,</span> <span class="n">vertical</span><span class="p">,</span> <span class="n">ranksep</span><span class="p">,</span> <span class="n">nodesep</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span>
                 <span class="n">float_format</span><span class="p">,</span> <span class="n">show_weight_one</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_FstDrawer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">fst</span><span class="p">,</span> <span class="n">isyms</span><span class="p">,</span> <span class="n">osyms</span><span class="p">,</span> <span class="n">ssyms</span><span class="p">,</span> <span class="n">accep</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span>
            <span class="n">portrait</span><span class="p">,</span> <span class="n">vertical</span><span class="p">,</span> <span class="n">ranksep</span><span class="p">,</span> <span class="n">nodesep</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span>
            <span class="n">float_format</span><span class="p">,</span> <span class="n">show_weight_one</span><span class="p">)</span>
        <span class="c1"># Keep references to these to keep them in scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fst</span> <span class="o">=</span> <span class="n">fst</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_isyms</span> <span class="o">=</span> <span class="n">isyms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_osyms</span> <span class="o">=</span> <span class="n">osyms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssyms</span> <span class="o">=</span> <span class="n">ssyms</span>


<span class="c1"># Printer API</span>

<span class="k">class</span> <span class="nc">_FstPrinter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the Python API for FST printers.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fst</span><span class="p">,</span> <span class="n">isyms</span><span class="p">,</span> <span class="n">osyms</span><span class="p">,</span> <span class="n">ssyms</span><span class="p">,</span> <span class="n">accep</span><span class="p">,</span> <span class="n">show_weight_one</span><span class="p">,</span>
                 <span class="n">field_separator</span><span class="p">,</span> <span class="n">missing_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_FstPrinter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">fst</span><span class="p">,</span> <span class="n">isyms</span><span class="p">,</span> <span class="n">osyms</span><span class="p">,</span> <span class="n">ssyms</span><span class="p">,</span> <span class="n">accep</span><span class="p">,</span> <span class="n">show_weight_one</span><span class="p">,</span>
            <span class="n">field_separator</span><span class="p">,</span> <span class="n">missing_symbol</span><span class="p">)</span>
        <span class="c1"># Keep references to these to keep them in scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fst</span> <span class="o">=</span> <span class="n">fst</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_isyms</span> <span class="o">=</span> <span class="n">isyms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_osyms</span> <span class="o">=</span> <span class="n">osyms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssyms</span> <span class="o">=</span> <span class="n">ssyms</span>


<span class="c1"># FST API</span>

<span class="k">class</span> <span class="nc">_FstBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the Python API for FST types.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_repr_svg_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;IPython notebook magic to produce an SVG of the FST using GraphViz.</span>

<span class="sd">        This method produces an SVG of the internal graph. Users wishing to</span>
<span class="sd">        create publication-quality graphs should instead use the method `draw`,</span>
<span class="sd">        which exposes additional parameters.</span>

<span class="sd">        Raises:</span>
<span class="sd">          RuntimeError: Cannot locate the `dot` executable.</span>
<span class="sd">          subprocess.CalledProcessError: `dot` returned non-zero exit code.</span>

<span class="sd">        See also: `draw`, `text`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Throws OSError if the dot executable is not found.</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">([</span><span class="s2">&quot;dot&quot;</span><span class="p">,</span> <span class="s2">&quot;-Tsvg&quot;</span><span class="p">],</span>
                                    <span class="n">stdin</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
                                    <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
                                    <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to execute &#39;dot -Tsvg&#39;, make sure &quot;</span>
                               <span class="s2">&quot;the Graphviz executable &#39;dot&#39; is on your PATH.&quot;</span><span class="p">)</span>
        <span class="n">sstrm</span> <span class="o">=</span> <span class="n">ostringstream</span><span class="p">()</span>
        <span class="n">fstdrawer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drawer_type</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_symbols</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_symbols</span><span class="p">(),</span> <span class="kc">None</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">(</span><span class="n">ACCEPTOR</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="n">ACCEPTOR</span><span class="p">,</span>
            <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">fstdrawer</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">sstrm</span><span class="p">,</span> <span class="s2">&quot;_repr_svg&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">sout</span><span class="p">,</span> <span class="n">serr</span><span class="p">)</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="n">sstrm</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">returncode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Just to be explicit.</span>
            <span class="k">raise</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">CalledProcessError</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">returncode</span><span class="p">,</span> <span class="s2">&quot;dot -Tsvg&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sout</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
            <span class="n">acceptor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">(</span><span class="n">ACCEPTOR</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="n">ACCEPTOR</span><span class="p">,</span>
            <span class="n">show_weight_one</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">(</span><span class="n">WEIGHTED</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="n">WEIGHTED</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_valid_state_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">(</span><span class="n">EXPANDED</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Cannot get number of states for unexpanded FST&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">count_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;State id </span><span class="si">{}</span><span class="s2"> not valid&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over arcs leaving the specified state.</span>

<span class="sd">        Args:</span>
<span class="sd">          state: The source state index.</span>

<span class="sd">        Returns:</span>
<span class="sd">          An ArcIterator.</span>

<span class="sd">        See also: `mutable_arcs`, `states`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arc_iterator_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Makes a copy of the FST.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the FST.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">isymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">osymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ssymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">acceptor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">8.5</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">portrait</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">vertical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ranksep</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">nodesep</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
             <span class="n">precision</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="n">show_weight_one</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes out the FST in Graphviz text format.</span>

<span class="sd">        This method writes out the FST in the dot graph description language.</span>
<span class="sd">        The graph can be rendered using the `dot` binary provided by Graphviz.</span>

<span class="sd">        Args:</span>
<span class="sd">          filename (str): The string location of the output dot/Graphviz file.</span>
<span class="sd">          isymbols: An optional symbol table used to label input symbols.</span>
<span class="sd">          osymbols: An optional symbol table used to label output symbols.</span>
<span class="sd">          ssymbols: An optional symbol table used to label states.</span>
<span class="sd">          acceptor (bool): Should the figure be rendered in acceptor format if</span>
<span class="sd">            possible? Defaults False.</span>
<span class="sd">          title (str): An optional string indicating the figure title. Defaults</span>
<span class="sd">            to empty string.</span>
<span class="sd">          width (float): The figure width, in inches. Defaults 8.5&#39;&#39;.</span>
<span class="sd">          height (float): The figure height, in inches. Defaults 11&#39;&#39;.</span>
<span class="sd">          portrait (bool): Should the figure be rendered in portrait rather than</span>
<span class="sd">            landscape? Defaults False.</span>
<span class="sd">          vertical (bool): Should the figure be rendered bottom-to-top rather</span>
<span class="sd">            than left-to-right?</span>
<span class="sd">          ranksep (float): The minimum separation separation between ranks,</span>
<span class="sd">            in inches. Defaults 0.4&#39;&#39;.</span>
<span class="sd">          nodesep (float): The minimum separation between nodes, in inches.</span>
<span class="sd">            Defaults 0.25&#39;&#39;.</span>
<span class="sd">          fontsize (int): Font size, in points. Defaults 14pt.</span>
<span class="sd">          precision (int): Numeric precision for floats, in number of chars.</span>
<span class="sd">            Defaults to 5.</span>
<span class="sd">          float_format (&#39;e&#39;, &#39;f&#39; or &#39;g&#39;): One of: &#39;e&#39;, &#39;f&#39; or &#39;g&#39;.</span>
<span class="sd">            Defaults to &#39;g&#39;</span>
<span class="sd">          show_weight_one (bool): Should weights equivalent to semiring One be</span>
<span class="sd">              printed? Defaults False.</span>

<span class="sd">        For more information about the rendering options, see `man dot`.</span>

<span class="sd">        See also: `text`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">isymbols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isymbols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_symbols</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">osymbols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">osymbols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_symbols</span><span class="p">()</span>
        <span class="n">ostrm</span> <span class="o">=</span> <span class="n">ofstream</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">fstdrawer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drawer_type</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">isymbols</span><span class="p">,</span> <span class="n">osymbols</span><span class="p">,</span> <span class="n">ssymbols</span><span class="p">,</span>
            <span class="n">acceptor</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">portrait</span><span class="p">,</span> <span class="n">vertical</span><span class="p">,</span> <span class="n">ranksep</span><span class="p">,</span>
            <span class="n">nodesep</span><span class="p">,</span> <span class="n">fontsize</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">float_format</span><span class="p">,</span> <span class="n">show_weight_one</span><span class="p">)</span>
        <span class="n">fstdrawer</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ostrm</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the final weight of a state.</span>

<span class="sd">        Args:</span>
<span class="sd">          state: The integer index of a state.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The final Weight of that state.</span>

<span class="sd">        Raises:</span>
<span class="sd">          IndexError: State index out of range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_state_id</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;State index out of range&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_bytes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the FST represented by the bytes object.</span>

<span class="sd">        Args:</span>
<span class="sd">            s (bytes): The bytes object representing the FST.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An FST object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">input_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the input symbol table.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The input symbol table.</span>

<span class="sd">        See Also: :meth:`output_symbols`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_symbols</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">num_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of arcs, counting them if necessary.</span>

<span class="sd">        If state is ``None``, returns the number of arcs in the FST. Otherwise,</span>
<span class="sd">        returns the number of arcs leaving that state.</span>

<span class="sd">        Args:</span>
<span class="sd">          state: The integer index of a state. Defaults to ``None``.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The number of arcs leaving a state or the number of arcs in the FST.</span>

<span class="sd">        Note:</span>
<span class="sd">        This method counts the number of arcs in the FST by iterating over the</span>
<span class="sd">        states and summing up the number of arcs leaving each state.</span>

<span class="sd">        Raises:</span>
<span class="sd">          IndexError: State index out of range.</span>

<span class="sd">        See also: `num_states`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">count_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_state_id</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;State index out of range&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_arcs</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">num_input_epsilons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of arcs with epsilon input labels leaving a state.</span>

<span class="sd">        Args:</span>
<span class="sd">          state: The integer index of a state.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The number of epsilon-input-labeled arcs leaving that state.</span>

<span class="sd">        Raises:</span>
<span class="sd">          IndexError: State index out of range.</span>

<span class="sd">        See also: `num_output_epsilons`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_state_id</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;State index out of range&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_input_epsilons</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">num_output_epsilons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of arcs with epsilon output labels leaving a state.</span>

<span class="sd">        Args:</span>
<span class="sd">          state: The integer index of a state.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The number of epsilon-output-labeled arcs leaving that state.</span>

<span class="sd">        Raises:</span>
<span class="sd">          IndexError: State index out of range.</span>

<span class="sd">        See also: `num_input_epsilons`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_state_id</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;State index out of range&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_output_epsilons</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">num_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of states, counting them if necessary.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The number of states.</span>

<span class="sd">        See also: `num_arcs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">count_states</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">output_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the output symbol table.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The output symbol table.</span>

<span class="sd">        See Also: :meth:`input_symbols`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_symbols</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">test</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provides property bits.</span>

<span class="sd">        This method provides user access to the properties attributes for the</span>
<span class="sd">        FST. The resulting value is a long integer, but when it is cast to a</span>
<span class="sd">        boolean, it represents whether or not the FST has the `mask` property.</span>

<span class="sd">        Args:</span>
<span class="sd">          mask: The property mask to be compared to the FST&#39;s properties.</span>
<span class="sd">          test: Should any unknown values be computed before comparing against</span>
<span class="sd">              the mask?</span>

<span class="sd">        Returns:</span>
<span class="sd">          A 64-bit bitmask representing the requested properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads an FST from a file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): The location of the input file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An FST object.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: Read failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_from_stream</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">strm</span><span class="p">,</span> <span class="n">ropts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads an FST from an input stream.</span>

<span class="sd">        Args:</span>
<span class="sd">            strm (istream): The input stream to read from.</span>
<span class="sd">            ropts (FstReadOptions): FST reading options.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An FST object.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: Read failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_read_from_stream</span><span class="p">(</span><span class="n">strm</span><span class="p">,</span> <span class="n">ropts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the start state.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The start state if start state is set, -1 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all states in the FST.</span>

<span class="sd">        Returns:</span>
<span class="sd">          A StateIterator object for the FST.</span>

<span class="sd">        See also: `arcs`, `mutable_arcs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_iterator_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">osymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ssymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">acceptor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">show_weight_one</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">missing_symbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces a human-readable string representation of the FST.</span>

<span class="sd">        This method generates a human-readable string representation of the FST.</span>
<span class="sd">        The caller may optionally specify SymbolTables used to label input</span>
<span class="sd">        labels, output labels, or state labels, respectively.</span>

<span class="sd">        Args:</span>
<span class="sd">          isymbols: An optional symbol table used to label input symbols.</span>
<span class="sd">          osymbols: An optional symbol table used to label output symbols.</span>
<span class="sd">          ssymbols: An optional symbol table used to label states.</span>
<span class="sd">          acceptor (bool): Should the FST be rendered in acceptor format if</span>
<span class="sd">            possible? Defaults False.</span>
<span class="sd">          show_weight_one (bool): Should weights equivalent to semiring One be</span>
<span class="sd">            printed? Defaults False.</span>
<span class="sd">          missing_symbol: The string to be printed when symbol table lookup</span>
<span class="sd">            fails.</span>

<span class="sd">        Returns:</span>
<span class="sd">          A formatted string representing the FST.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">isymbols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isymbols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_symbols</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">osymbols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">osymbols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_symbols</span><span class="p">()</span>
        <span class="n">sstrm</span> <span class="o">=</span> <span class="n">ostringstream</span><span class="p">()</span>
        <span class="n">fstprinter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_printer_type</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">isymbols</span><span class="p">,</span> <span class="n">osymbols</span><span class="p">,</span> <span class="n">ssymbols</span><span class="p">,</span>
            <span class="n">acceptor</span><span class="p">,</span> <span class="n">show_weight_one</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">missing_symbol</span><span class="p">)</span>
        <span class="n">fstprinter</span><span class="o">.</span><span class="n">print_fst</span><span class="p">(</span><span class="n">sstrm</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sstrm</span><span class="o">.</span><span class="n">to_str</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a bytes object representing the FST.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A bytes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the FST type.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The FST type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verifies that an FST&#39;s contents are sane.</span>

<span class="sd">        Returns:</span>
<span class="sd">          True if the contents are sane, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verify</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Serializes FST to a file.</span>

<span class="sd">        This method writes the FST to a file in a binary format.</span>

<span class="sd">        Args:</span>
<span class="sd">          filename (str): The location of the output file.</span>

<span class="sd">        Raises:</span>
<span class="sd">          IOError: Write failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Write failed: </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">write_to_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strm</span><span class="p">,</span> <span class="n">wopts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Serializes FST to an output stream.</span>

<span class="sd">        Args:</span>
<span class="sd">            strm (ostream): The output stream to write to.</span>
<span class="sd">            wopts (FstWriteOptions): FST writing options.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if write was successful, False otherwise.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: Write failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_stream</span><span class="p">(</span><span class="n">strm</span><span class="p">,</span> <span class="n">wopts</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MutableFstBase</span><span class="p">(</span><span class="n">_FstBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the Python API for mutable Fst types.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_check_mutating_imethod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether an operation mutating the FST has produced an error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Operation failed&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_arc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">arc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new arc to the FST and returns self.</span>

<span class="sd">        Args:</span>
<span class="sd">          state: The integer index of the source state.</span>
<span class="sd">          arc: The arc to add.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        Raises:</span>
<span class="sd">          IndexError: State index out of range.</span>

<span class="sd">        See also: `add_state`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_state_id</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;State index out of range&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_arc</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">arc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new state to the FST and returns the state ID.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The integer index of the new state.</span>

<span class="sd">        See also: `add_arc`, `set_start`, `set_final`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_state</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">arcsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort_type</span><span class="o">=</span><span class="s2">&quot;ilabel&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts arcs leaving each state of the FST.</span>

<span class="sd">        This operation destructively sorts arcs leaving each state using either</span>
<span class="sd">        input or output labels.</span>

<span class="sd">        Args:</span>
<span class="sd">          sort_type: Either &quot;ilabel&quot; (sort arcs according to input labels) or</span>
<span class="sd">              &quot;olabel&quot; (sort arcs according to output labels).</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        Raises:</span>
<span class="sd">          ValueError: Unknown sort type.</span>

<span class="sd">        See also: `topsort`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sort_type</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetArcSortType</span><span class="p">(</span><span class="n">sort_type</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown sort type </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sort_type</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">arcsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">closure_plus</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes concatenative closure.</span>

<span class="sd">        This operation destructively converts the FST to its concatenative</span>
<span class="sd">        closure. If A transduces string x to y with weight a, then the closure</span>
<span class="sd">        transduces x to y with weight a, xx to yy with weight a \\otimes a,</span>
<span class="sd">        xxx to yyy with weight a \\otimes a \\otimes a, and so on. The empty</span>
<span class="sd">        string is also transduced to itself with semiring One if `closure_plus`</span>
<span class="sd">        is False.</span>

<span class="sd">        Args:</span>
<span class="sd">          closure_plus: If True, do not accept the empty string.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">closure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetClosureType</span><span class="p">(</span><span class="n">closure_plus</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ifst</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the concatenation (product) of two FSTs.</span>

<span class="sd">        This operation destructively concatenates the FST with a second FST. If</span>
<span class="sd">        A transduces string x to y with weight a and B transduces string w to v</span>
<span class="sd">        with weight b, then their concatenation transduces string xw to yv with</span>
<span class="sd">        weight a \\otimes b.</span>

<span class="sd">        Args:</span>
<span class="sd">          ifst: The second input FST.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ifst</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes unsuccessful paths.</span>

<span class="sd">        This operation destructively trims the FST, removing states and arcs</span>
<span class="sd">        that are not part of any successful path.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoder</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decodes encoded labels and/or weights.</span>

<span class="sd">        This operation reverses the encoding performed by `encode`.</span>

<span class="sd">        Args:</span>
<span class="sd">          encoder: An EncodeMapper object used to encode the FST.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        See also: `encode`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoder</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">delete_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes arcs leaving a particular state.</span>

<span class="sd">        Args:</span>
<span class="sd">          state: The integer index of a state.</span>
<span class="sd">          n: An optional argument indicating how many arcs to be deleted.</span>
<span class="sd">              If this argument is None, all arcs from this state are deleted.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        Raises:</span>
<span class="sd">          IndexError: State index out of range.</span>

<span class="sd">        See also: `delete_states`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_state_id</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;State index out of range&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delete_arcs</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delete_all_arcs</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">delete_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes states.</span>

<span class="sd">        Args:</span>
<span class="sd">          states: An optional iterable of integer indices of the states to be</span>
<span class="sd">              deleted. If this argument is omitted, all states are deleted.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        Raises:</span>
<span class="sd">          IndexError: State index out of range.</span>

<span class="sd">        See also: `delete_arcs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">states</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_state_id</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;State index out of range&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete_states</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete_all_states</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoder</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encodes labels and/or weights.</span>

<span class="sd">        This operation allows for the representation of a weighted transducer as</span>
<span class="sd">        a weighted acceptor, an unweighted transducer, or an unweighted acceptor</span>
<span class="sd">        by considering the pair (input label, output label), the pair (input</span>
<span class="sd">        label, weight), or the triple (input label, output label, weight) as a</span>
<span class="sd">        single label. Applying this operation mutates the EncodeMapper argument,</span>
<span class="sd">        which can then be used to decode.</span>

<span class="sd">        Args:</span>
<span class="sd">          encoder: An EncodeMapper object used to encode the FST.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        See also: `decode`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoder</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverts the FST&#39;s transduction.</span>

<span class="sd">        This operation destructively inverts the FST&#39;s transduction by</span>
<span class="sd">        exchanging input and output labels.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">,</span> <span class="n">allow_nondet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Minimizes the FST.</span>

<span class="sd">        This operation destructively performs the minimization of deterministic</span>
<span class="sd">        weighted automata and transducers. If the input FST A is an acceptor,</span>
<span class="sd">        this operation produces the minimal acceptor B equivalent to A, i.e. the</span>
<span class="sd">        acceptor with a minimal number of states that is equivalent to A. If the</span>
<span class="sd">        input FST A is a transducer, this operation internally builds an</span>
<span class="sd">        equivalent transducer with a minimal number of states. However, this</span>
<span class="sd">        minimality is obtained by allowing transitions to have strings of</span>
<span class="sd">        symbols as output labels, this is known in the literature as a real-time</span>
<span class="sd">        transducer. Such transducers are not directly supported by the library.</span>
<span class="sd">        This function will convert such transducers by expanding each</span>
<span class="sd">        string-labeled transition into a sequence of transitions. This will</span>
<span class="sd">        result in the creation of new states, hence losing the minimality</span>
<span class="sd">        property.</span>

<span class="sd">        Args:</span>
<span class="sd">          delta: Comparison/quantization delta (default: 0.0009765625).</span>
<span class="sd">          allow_nondet: Attempt minimization of non-deterministic FST?</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">allow_nondet</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">mutable_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a mutable iterator over arcs leaving the specified state.</span>

<span class="sd">        Args:</span>
<span class="sd">          state: The source state index.</span>

<span class="sd">        Returns:</span>
<span class="sd">          A MutableArcIterator.</span>

<span class="sd">        See also: `arcs`, `states`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutable_arc_iterator_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project_output</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the FST to an acceptor using input or output labels.</span>

<span class="sd">        This operation destructively projects an FST onto its domain or range by</span>
<span class="sd">        either copying each arc&#39;s input label to its output label (the default)</span>
<span class="sd">        or vice versa.</span>

<span class="sd">        Args:</span>
<span class="sd">          project_output: Project onto output labels?</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        See also: `decode`, `encode`, `relabel`, `relabel_tables`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetProjectType</span><span class="p">(</span><span class="n">project_output</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">prune</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nstate</span><span class="o">=</span><span class="n">NO_STATE_ID</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes paths with weights below a certain threshold.</span>

<span class="sd">        This operation deletes states and arcs in the input FST that do not</span>
<span class="sd">        belong to a successful path whose weight is no more (w.r.t the natural</span>
<span class="sd">        semiring order) than the threshold \\otimes the weight of the shortest</span>
<span class="sd">        path in the input FST. Weights must be commutative and have the path</span>
<span class="sd">        property.</span>

<span class="sd">        Args:</span>
<span class="sd">          weight: A Weight in the FST semiring or an object that can be</span>
<span class="sd">              converted to a Weight in the FST semiring indicating the desired</span>
<span class="sd">              weight threshold below which paths are pruned; if None, no paths</span>
<span class="sd">              are pruned.</span>
<span class="sd">          nstate: State number threshold (default: -1).</span>
<span class="sd">          delta: Comparison/quantization delta (default: 0.0009765625).</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        See also: The constructive variant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Threshold is set to semiring Zero (no pruning) if weight is None.</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_weight_or_default</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weight_factory</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">prune</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nstate</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_final</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">,</span>
             <span class="n">remove_total_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pushes weights towards the initial or final states.</span>

<span class="sd">        This operation destructively produces an equivalent transducer by</span>
<span class="sd">        pushing the weights towards the initial state or toward the final</span>
<span class="sd">        states. When pushing weights towards the initial state, the sum of the</span>
<span class="sd">        weight of the outgoing transitions and final weight at any non-initial</span>
<span class="sd">        state is equal to one in the resulting machine. When pushing weights</span>
<span class="sd">        towards the final states, the sum of the weight of the incoming</span>
<span class="sd">        transitions at any state is equal to one. Weights need to be left</span>
<span class="sd">        distributive when pushing towards the initial state and right</span>
<span class="sd">        distributive when pushing towards the final states.</span>

<span class="sd">        Args:</span>
<span class="sd">          to_final: Push towards final states?</span>
<span class="sd">          delta: Comparison/quantization delta (default: 0.0009765625).</span>
<span class="sd">          remove_total_weight: If pushing weights, should the total weight be</span>
<span class="sd">              removed?</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        See also: The constructive variant, which also supports label pushing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetReweightType</span><span class="p">(</span><span class="n">to_final</span><span class="p">),</span>
                       <span class="n">delta</span><span class="p">,</span> <span class="n">remove_total_weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ipairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">opairs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces input and/or output labels using pairs of labels.</span>

<span class="sd">        This operation destructively relabels the input and/or output labels of</span>
<span class="sd">        the FST using pairs of the form (old_ID, new_ID); omitted indices are</span>
<span class="sd">        identity-mapped.</span>

<span class="sd">        Args:</span>
<span class="sd">          ipairs: An iterable containing (old index, new index) integer pairs.</span>
<span class="sd">          opairs: An iterable containing (old index, new index) integer pairs.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        Raises:</span>
<span class="sd">          ValueError: No relabeling pairs specified.</span>

<span class="sd">        See also: `decode`, `encode`, `project`, `relabel_tables`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ipairs</span><span class="p">:</span>
            <span class="n">ipairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">opairs</span><span class="p">:</span>
            <span class="n">opairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ipairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">opairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No relabeling pairs specified.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ipairs</span><span class="p">,</span> <span class="n">opairs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">relabel_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_isymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_isymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">unknown_isymbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">attach_new_isymbols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">old_osymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_osymbols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">unknown_osymbol</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">attach_new_osymbols</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces input and/or output labels using SymbolTables.</span>

<span class="sd">        This operation destructively relabels the input and/or output labels of</span>
<span class="sd">        the FST using user-specified symbol tables; omitted symbols are</span>
<span class="sd">        identity-mapped.</span>

<span class="sd">        Args:</span>
<span class="sd">           old_isymbols: The old SymbolTable for input labels, defaulting to the</span>
<span class="sd">              FST&#39;s input symbol table.</span>
<span class="sd">           new_isymbols: A SymbolTable used to relabel the input labels</span>
<span class="sd">           unknown_isymbol: Input symbol to use to relabel OOVs (if empty,</span>
<span class="sd">              OOVs raise an exception)</span>
<span class="sd">           attach_new_isymbols: Should new_isymbols be made the FST&#39;s input</span>
<span class="sd">              symbol table?</span>
<span class="sd">           old_osymbols: The old SymbolTable for output labels, defaulting to</span>
<span class="sd">              the FST&#39;s output symbol table.</span>
<span class="sd">           new_osymbols: A SymbolTable used to relabel the output labels.</span>
<span class="sd">           unknown_osymbol: Outnput symbol to use to relabel OOVs (if empty,</span>
<span class="sd">              OOVs raise an exception)</span>
<span class="sd">           attach_new_osymbols: Should new_osymbols be made the FST&#39;s output</span>
<span class="sd">              symbol table?</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        Raises:</span>
<span class="sd">          ValueError: No SymbolTable specified.</span>

<span class="sd">        See also: `decode`, `encode`, `project`, `relabel`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_isymbols</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_osymbols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No new symbol tables specified&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">relabel_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_input_symbols</span><span class="p">()</span> <span class="k">if</span> <span class="n">old_isymbols</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">old_isymbols</span><span class="p">,</span>
            <span class="n">new_isymbols</span><span class="p">,</span> <span class="n">unknown_isymbol</span><span class="p">,</span> <span class="n">attach_new_isymbols</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_output_symbols</span><span class="p">()</span> <span class="k">if</span> <span class="n">old_osymbols</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">old_osymbols</span><span class="p">,</span>
            <span class="n">new_osymbols</span><span class="p">,</span> <span class="n">unknown_osymbol</span><span class="p">,</span> <span class="n">attach_new_osymbols</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">reserve_arcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reserve n arcs at a particular state (best effort).</span>

<span class="sd">        Args:</span>
<span class="sd">          state: The integer index of a state.</span>
<span class="sd">          n: The number of arcs to reserve.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        Raises:</span>
<span class="sd">          IndexError: State index out of range.</span>

<span class="sd">        See also: `reserve_states`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_state_id</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;State index out of range&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reserve_arcs</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">reserve_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reserve n states (best effort).</span>

<span class="sd">        Args:</span>
<span class="sd">          n: The number of states to reserve.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        See also: `reserve_arcs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reserve_states</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">reweight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">potentials</span><span class="p">,</span> <span class="n">to_final</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reweights an FST using an iterable of potentials.</span>

<span class="sd">        This operation destructively reweights an FST according to the</span>
<span class="sd">        potentials and in the direction specified by the user. An arc of weight</span>
<span class="sd">        w, with an origin state of potential p and destination state of</span>
<span class="sd">        potential q, is reweighted by p^{-1} \\otimes (w \\otimes q) when</span>
<span class="sd">        reweighting towards the initial state, and by (p \\otimes w) \\otimes</span>
<span class="sd">        q^{-1} when reweighting towards the final states. The weights must be</span>
<span class="sd">        left distributive when reweighting towards the initial state and right</span>
<span class="sd">        distributive when reweighting towards the final states (e.g.,</span>
<span class="sd">        TropicalWeight and LogWeight).</span>

<span class="sd">        Args:</span>
<span class="sd">          potentials: An iterable of TropicalWeights.</span>
<span class="sd">          to_final: Push towards final states?</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">reweight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">potentials</span><span class="p">,</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetReweightType</span><span class="p">(</span><span class="n">to_final</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">rmepsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">nstate</span><span class="o">=</span><span class="n">NO_STATE_ID</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes epsilon transitions.</span>

<span class="sd">        This operation destructively removes epsilon transitions, i.e., those</span>
<span class="sd">        where both input and output labels are epsilon) from an FST.</span>

<span class="sd">        Args:</span>
<span class="sd">          connect: Should output be trimmed?</span>
<span class="sd">          weight: A Weight in the FST semiring or an object that can be</span>
<span class="sd">              converted to a Weight in the FST semiring indicating the desired</span>
<span class="sd">              weight threshold below which paths are pruned; if None, no paths</span>
<span class="sd">              are pruned.</span>
<span class="sd">          nstate: State number threshold (default: -1).</span>
<span class="sd">          delta: Comparison/quantization delta (default: 0.0009765625).</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        See also: The constructive variant, which also supports epsilon removal</span>
<span class="sd">            in reverse (and which may be more efficient).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Threshold is set to semiring Zero (no pruning) if weight is None.</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_weight_or_default</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weight_factory</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">rmepsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connect</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nstate</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set_final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the final weight for a state.</span>

<span class="sd">        Args:</span>
<span class="sd">          state: The integer index of a state.</span>
<span class="sd">          weight: A Weight in the FST semiring or an object that can be</span>
<span class="sd">              converted to a Weight in the FST semiring indicating the desired</span>
<span class="sd">              final weight; if omitted, it is set to semiring One.</span>

<span class="sd">        Raises:</span>
<span class="sd">          IndexError: State index out of range.</span>

<span class="sd">        See also: `set_start`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_state_id</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;State index out of range&quot;</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_weight_or_default</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weight_factory</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_final</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set_input_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the input symbol table.</span>

<span class="sd">        Passing ``None`` as a value will delete the input symbol table.</span>

<span class="sd">        Args:</span>
<span class="sd">          syms: A SymbolTable.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        See also: `set_output_symbols`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_input_symbols</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set_output_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the output symbol table.</span>

<span class="sd">        Passing ``None`` as a value will delete the output symbol table.</span>

<span class="sd">        Args:</span>
<span class="sd">          syms: A SymbolTable.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        See also: `set_input_symbols`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_symbols</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">props</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the properties bits.</span>

<span class="sd">        Args:</span>
<span class="sd">          props (int): The properties to be set.</span>
<span class="sd">          mask (int): A mask to be applied to the `props` argument before</span>
<span class="sd">            setting the FST&#39;s properties.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_properties</span><span class="p">(</span><span class="n">props</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the initial state.</span>

<span class="sd">        Args:</span>
<span class="sd">          state: The integer index of a state.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>

<span class="sd">        Raises:</span>
<span class="sd">          IndexError: State index out of range.</span>

<span class="sd">        See also: `set_final`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_state_id</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;State index out of range&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_start</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">topsort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts transitions by state IDs.</span>

<span class="sd">        This operation destructively topologically sorts the FST, if it is</span>
<span class="sd">        acyclic; otherwise it remains unchanged. Once sorted, all transitions</span>
<span class="sd">        are from lower state IDs to higher state IDs</span>

<span class="sd">        Returns:</span>
<span class="sd">           self.</span>

<span class="sd">        See also: `arcsort`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># _topsort returns False if the FST is cyclic.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">topsort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
          <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot topsort cyclic FST.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ifst</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the union (sum) of two FSTs.</span>

<span class="sd">        This operation computes the union (sum) of two FSTs. If A transduces</span>
<span class="sd">        string x to y with weight a and B transduces string w to v with weight</span>
<span class="sd">        b, then their union transduces x to y with weight a and w to v with</span>
<span class="sd">        weight b.</span>

<span class="sd">        Args:</span>
<span class="sd">          ifst: The second input FST.</span>

<span class="sd">        Returns:</span>
<span class="sd">          self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ifst</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_mutating_imethod</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="c1"># FST Iterators</span>

<span class="k">class</span> <span class="nc">_StateIteratorBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the Python API for state iterator types.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fst</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new state iterator.</span>

<span class="sd">        Args:</span>
<span class="sd">            fst: The fst.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_StateIteratorBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fst</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Advances the iterator.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Indicates whether the iterator is exhausted or not.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>

<span class="sd">        Returns:</span>
<span class="sd">          True if the iterator is exhausted, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the iterator to the initial position.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current state index.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_ArcIteratorBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the Python API for arc iterator types.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fst</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new arc iterator.</span>

<span class="sd">        Args:</span>
<span class="sd">            fst: The fst.</span>
<span class="sd">            state: The state index.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: State index out of range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fst</span><span class="o">.</span><span class="n">_valid_state_id</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;State index out of range&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_ArcIteratorBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fst</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Advances the iterator.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Indicates whether the iterator is exhausted or not.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>

<span class="sd">        Returns:</span>
<span class="sd">          True if the iterator is exhausted, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current iterator behavioral flags.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The current iterator behavioral flags as an integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flags</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the position of the iterator.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>

<span class="sd">        Returns:</span>
<span class="sd">          The iterator&#39;s position, expressed as an integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the iterator to the initial position.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Advance the iterator to a new position.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>

<span class="sd">        Args:</span>
<span class="sd">          a (int): The position to seek to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seek</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the current iterator behavioral flags.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>

<span class="sd">        Args:</span>
<span class="sd">          flags (int): The properties to be set.</span>
<span class="sd">          mask (int): A mask to be applied to the `flags` argument before</span>
<span class="sd">            setting them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current arc.</span>

<span class="sd">        This method is provided for compatibility with the C++ API only;</span>
<span class="sd">        most users should use the Pythonic API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_MutableArcIteratorBase</span><span class="p">(</span><span class="n">_ArcIteratorBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the Python API for mutable arc iterator types.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace the current arc with a new arc.</span>

<span class="sd">        Args:</span>
<span class="sd">          arc: The arc to replace the current arc with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_value</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span>


<span class="c1"># FST Operations</span>

<div class="viewcode-block" id="arcmap"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.arcmap">[docs]</a><span class="k">def</span> <span class="nf">arcmap</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">map_type</span><span class="o">=</span><span class="s2">&quot;identity&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively applies a transform to all arcs and final states.</span>

<span class="sd">    This operation transforms each arc and final state in the input FST</span>
<span class="sd">    using one of the following:</span>

<span class="sd">    * identity: maps to self.</span>
<span class="sd">    * input_epsilon: replaces all input labels with epsilon.</span>
<span class="sd">    * invert: reciprocates all non-Zero weights.</span>
<span class="sd">    * output_epsilon: replaces all output labels with epsilon.</span>
<span class="sd">    * plus: adds a constant to all weights.</span>
<span class="sd">    * quantize: quantizes weights.</span>
<span class="sd">    * rmweight: replaces all non-Zero weights with 1.</span>
<span class="sd">    * superfinal: redirects final states to a new superfinal state.</span>
<span class="sd">    * times: right-multiplies a constant to all weights.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        map_type: A string matching a known mapping operation (see above).</span>
<span class="sd">        delta: Comparison/quantization delta (ignored unless `map_type` is</span>
<span class="sd">            `quantize`, default: 0.0009765625).</span>
<span class="sd">        weight: A Weight in the FST semiring or an object that can be converted</span>
<span class="sd">            to a Weight in the FST semiring passed to the arc-mapper; this is</span>
<span class="sd">            ignored unless `map_type` is `plus` (in which case it defaults</span>
<span class="sd">            to semiring Zero) or `times` (in which case it defaults to</span>
<span class="sd">            semiring One).</span>

<span class="sd">    Returns:</span>
<span class="sd">        An FST with arcs and final states remapped.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Unknown map type.</span>

<span class="sd">    See also: `statemap`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NB: Weight conversion mappers are not supported.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">map_type</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetMapType</span><span class="p">(</span><span class="n">map_type</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown map type: </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">map_type</span><span class="p">))</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_weight_or_default</span><span class="p">(</span><span class="n">ifst</span><span class="o">.</span><span class="n">_weight_factory</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span>
                                    <span class="n">map_type</span> <span class="o">==</span> <span class="n">MapType</span><span class="o">.</span><span class="n">TIMES_MAPPER</span><span class="p">)</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">map_type</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="compose"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.compose">[docs]</a><span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compose_filter</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively composes two FSTs.</span>

<span class="sd">    This operation computes the composition of two FSTs. If A transduces</span>
<span class="sd">    string x to y with weight a and B transduces y to z with weight b, then</span>
<span class="sd">    their composition transduces string x to z with weight a \\otimes b. The</span>
<span class="sd">    output labels of the first transducer or the input labels of the second</span>
<span class="sd">    transducer must be sorted (or otherwise support appropriate matchers).</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst1: The first input FST.</span>
<span class="sd">        ifst2: The second input FST.</span>
<span class="sd">        connect: Should output be trimmed?</span>
<span class="sd">        compose_filter: A string matching a known composition filter; one of:</span>
<span class="sd">            &quot;alt_sequence&quot;, &quot;auto&quot;, &quot;match&quot;, &quot;null&quot;, &quot;sequence&quot;, &quot;trivial&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A composed FST.</span>

<span class="sd">    See also: `arcsort`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">compose_filter</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetComposeFilter</span><span class="p">(</span><span class="n">compose_filter</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown compose filter: </span><span class="si">{!r}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">compose_filter</span><span class="p">))</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst1</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst1</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">connect</span><span class="p">,</span> <span class="n">compose_filter</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="determinize"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.determinize">[docs]</a><span class="k">def</span> <span class="nf">determinize</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nstate</span><span class="o">=</span><span class="n">NO_STATE_ID</span><span class="p">,</span>
                <span class="n">subsequential_label</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">det_type</span><span class="o">=</span><span class="s2">&quot;functional&quot;</span><span class="p">,</span>
                <span class="n">increment_subsequential_label</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively determinizes a weighted FST.</span>

<span class="sd">    This operations creates an equivalent FST that has the property that no</span>
<span class="sd">    state has two transitions with the same input label. For this algorithm,</span>
<span class="sd">    epsilon transitions are treated as regular symbols (cf. `rmepsilon`).</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        delta: Comparison/quantization delta (default: 0.0009765625).</span>
<span class="sd">        weight: A Weight in the FST semiring or an object that can be converted</span>
<span class="sd">            to a Weight in the FST semiring indicating the desired weight</span>
<span class="sd">            threshold below which paths are pruned; if None, no paths are</span>
<span class="sd">            pruned.</span>
<span class="sd">        nstate: State number threshold (default: -1).</span>
<span class="sd">        subsequential_label: Input label of arc corresponding to residual final</span>
<span class="sd">            output when producing a subsequential transducer.</span>
<span class="sd">        det_type: Type of determinization; one of: &quot;functional&quot; (input</span>
<span class="sd">            transducer is functional), &quot;nonfunctional&quot; (input transducer is not</span>
<span class="sd">            functional) and disambiguate&quot; (input transducer is not functional</span>
<span class="sd">            but only keep the min of ambiguous outputs).</span>
<span class="sd">        increment_subsequential_label: Increment subsequential when creating</span>
<span class="sd">            several arcs for the residual final output at a given state.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An equivalent deterministic FST.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Unknown determinization type.</span>

<span class="sd">    See also: `disambiguate`, `rmepsilon`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">det_type</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetDeterminizeType</span><span class="p">(</span><span class="n">det_type</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown determinization type: </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det_type</span><span class="p">))</span>
    <span class="c1"># Threshold is set to semiring Zero (no pruning) if weight is None.</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_weight_or_default</span><span class="p">(</span><span class="n">ifst</span><span class="o">.</span><span class="n">_weight_factory</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">determinize</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nstate</span><span class="p">,</span>
                          <span class="n">subsequential_label</span><span class="p">,</span> <span class="n">det_type</span><span class="p">,</span>
                          <span class="n">increment_subsequential_label</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="difference"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.difference">[docs]</a><span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compose_filter</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively computes the difference of two FSTs.</span>

<span class="sd">    This operation computes the difference between two FSAs. Only strings that</span>
<span class="sd">    are in the first automaton but not in second are retained in the result. The</span>
<span class="sd">    first argument must be an acceptor; the second argument must be an</span>
<span class="sd">    unweighted, epsilon-free, deterministic acceptor. The output labels of the</span>
<span class="sd">    first transducer or the input labels of the second transducer must be sorted</span>
<span class="sd">    (or otherwise support appropriate matchers).</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst1: The first input FST.</span>
<span class="sd">        ifst2: The second input FST.</span>
<span class="sd">        connect: Should the output FST be trimmed?</span>
<span class="sd">        compose_filter: A string matching a known composition filter; one of:</span>
<span class="sd">            &quot;alt_sequence&quot;, &quot;auto&quot;, &quot;match&quot;, &quot;null&quot;, &quot;sequence&quot;, &quot;trivial&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An FST representing the difference of the FSTs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">compose_filter</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetComposeFilter</span><span class="p">(</span><span class="n">compose_filter</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown compose filter: </span><span class="si">{!r}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">compose_filter</span><span class="p">))</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst1</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst1</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">connect</span><span class="p">,</span> <span class="n">compose_filter</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>

<div class="viewcode-block" id="disambiguate"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.disambiguate">[docs]</a><span class="k">def</span> <span class="nf">disambiguate</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">nstate</span><span class="o">=</span><span class="n">NO_STATE_ID</span><span class="p">,</span> <span class="n">subsequential_label</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively disambiguates a weighted transducer.</span>

<span class="sd">    This operation disambiguates a weighted transducer. The result will be an</span>
<span class="sd">    equivalent FST that has the property that no two successful paths have the</span>
<span class="sd">    same input labeling. For this algorithm, epsilon transitions are treated as</span>
<span class="sd">    regular symbols (cf. `rmepsilon`).</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        delta: Comparison/quantization delta (default: 0.0009765625).</span>
<span class="sd">        weight: A Weight in the FST semiring or an object that can be converted</span>
<span class="sd">            to a Weight in the FST semiring indicating the desired weight</span>
<span class="sd">            threshold below which paths are pruned; if None, no paths are</span>
<span class="sd">            pruned.</span>
<span class="sd">        nstate: State number threshold.</span>
<span class="sd">        subsequential_label: Input label of arc corresponding to residual final</span>
<span class="sd">            output when producing a subsequential transducer.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An equivalent disambiguated FST.</span>

<span class="sd">    See also: `determinize`, `rmepsilon`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Threshold is set to semiring Zero (no pruning) if weight is None.</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_weight_or_default</span><span class="p">(</span><span class="n">ifst</span><span class="o">.</span><span class="n">_weight_factory</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">disambiguate</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nstate</span><span class="p">,</span>
                           <span class="n">subsequential_label</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="epsnormalize"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.epsnormalize">[docs]</a><span class="k">def</span> <span class="nf">epsnormalize</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">eps_norm_output</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively epsilon-normalizes an FST.</span>

<span class="sd">    This operation creates an equivalent FST that is epsilon-normalized. An</span>
<span class="sd">    acceptor is epsilon-normalized if it it is epsilon-removed (cf.</span>
<span class="sd">    `rmepsilon`). A transducer is input epsilon-normalized if, in addition,</span>
<span class="sd">    along any path, all arcs with epsilon input labels follow all arcs with</span>
<span class="sd">    non-epsilon input labels. Output epsilon-normalized is defined similarly.</span>
<span class="sd">    The input FST must be functional.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        eps_norm_output: Should the FST be output epsilon-normalized?</span>

<span class="sd">    Returns:</span>
<span class="sd">        An equivalent epsilon-normalized FST.</span>

<span class="sd">    See also: `rmepsilon`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">eps_norm_output</span><span class="p">:</span>
        <span class="n">eps_norm_type</span> <span class="o">=</span> <span class="n">EpsNormalizeType</span><span class="o">.</span><span class="n">EPS_NORM_OUTPUT</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eps_norm_type</span> <span class="o">=</span> <span class="n">EpsNormalizeType</span><span class="o">.</span><span class="n">EPS_NORM_INPUT</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">epsnormalize</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">eps_norm_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="equal"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.equal">[docs]</a><span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Are two FSTs equal?</span>

<span class="sd">    This function tests whether two FSTs have the same states with the same</span>
<span class="sd">    numbering and the same transitions with the same labels and weights in the</span>
<span class="sd">    same order.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst1: The first input FST.</span>
<span class="sd">        ifst2: The second input FST.</span>
<span class="sd">        delta: Comparison/quantization delta (0.0009765625).</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if the FSTs satisfy the above condition, else False.</span>

<span class="sd">    See also: `equivalent`, `isomorphic`, `randequivalent`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ifst1</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></div>


<div class="viewcode-block" id="equivalent"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.equivalent">[docs]</a><span class="k">def</span> <span class="nf">equivalent</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Are the two acceptors equivalent?</span>

<span class="sd">    This operation tests whether two epsilon-free deterministic weighted</span>
<span class="sd">    acceptors are equivalent, that is if they accept the same strings with the</span>
<span class="sd">    same weights.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst1: The first input FST.</span>
<span class="sd">        ifst2: The second input FST.</span>
<span class="sd">        delta: Comparison/quantization delta (default: 0.0009765625).</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if the FSTs satisfy the above condition, else False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: Equivalence test encountered error.</span>

<span class="sd">    See also: `equal`, `isomorphic`, `randequivalent`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="n">ifst1</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">equivalent</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Equivalence test encountered error&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="intersect"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.intersect">[docs]</a><span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compose_filter</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively intersects two FSTs.</span>

<span class="sd">    This operation computes the intersection (Hadamard product) of two FSTs.</span>
<span class="sd">    Only strings that are in both automata are retained in the result. The two</span>
<span class="sd">    arguments must be acceptors. One of the arguments must be label-sorted (or</span>
<span class="sd">    otherwise support appropriate matchers).</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst1: The first input FST.</span>
<span class="sd">        ifst2: The second input FST.</span>
<span class="sd">        connect: Should output be trimmed?</span>
<span class="sd">        compose_filter: A string matching a known composition filter; one of:</span>
<span class="sd">            &quot;alt_sequence&quot;, &quot;auto&quot;, &quot;match&quot;, &quot;null&quot;, &quot;sequence&quot;, &quot;trivial&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An intersected FST.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">compose_filter</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetComposeFilter</span><span class="p">(</span><span class="n">compose_filter</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown compose filter: </span><span class="si">{!r}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">compose_filter</span><span class="p">))</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst1</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst1</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">connect</span><span class="p">,</span> <span class="n">compose_filter</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="isomorphic"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.isomorphic">[docs]</a><span class="k">def</span> <span class="nf">isomorphic</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Are the two acceptors isomorphic?</span>

<span class="sd">    This operation determines if two transducers with a certain required</span>
<span class="sd">    determinism have the same states, irrespective of numbering, and the same</span>
<span class="sd">    transitions with the same labels and weights, irrespective of ordering. In</span>
<span class="sd">    other words, FSTs A, B are isomorphic if and only if the states of A can be</span>
<span class="sd">    renumbered and the transitions leaving each state reordered so the two are</span>
<span class="sd">    equal (according to the definition given in `equal`).</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst1: The first input FST.</span>
<span class="sd">        ifst2: The second input FST.</span>
<span class="sd">        delta: Comparison/quantization delta (default: 0.0009765625).</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if the two transducers satisfy the above condition, else False.</span>

<span class="sd">    See also: `equal`, `equivalent`, `randequivalent`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ifst1</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">isomorphic</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></div>


<div class="viewcode-block" id="prune"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.prune">[docs]</a><span class="k">def</span> <span class="nf">prune</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nstate</span><span class="o">=</span><span class="n">NO_STATE_ID</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively removes paths with weights below a certain threshold.</span>

<span class="sd">    This operation deletes states and arcs in the input FST that do not belong</span>
<span class="sd">    to a successful path whose weight is no more (w.r.t the natural semiring</span>
<span class="sd">    order) than the threshold t \\otimes the weight of the shortest path in</span>
<span class="sd">    the input FST. Weights must be commutative and have the path property.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        weight: A Weight in the FST semiring or an object that can be converted</span>
<span class="sd">            to a Weight in the FST semiring indicating the desired weight</span>
<span class="sd">            threshold below which paths are pruned; if None, no paths are</span>
<span class="sd">            pruned.</span>
<span class="sd">        nstate: State number threshold (default: -1).</span>
<span class="sd">        delta: Comparison/quantization delta (default: 0.0009765625).</span>

<span class="sd">    Returns:</span>
<span class="sd">        A pruned FST.</span>

<span class="sd">    See also: The destructive variant.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Threshold is set to semiring Zero (no pruning) if weight is None.</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_weight_or_default</span><span class="p">(</span><span class="n">ifst</span><span class="o">.</span><span class="n">_weight_factory</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">prune_cons</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nstate</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="push"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.push">[docs]</a><span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">push_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">push_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">remove_common_affix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
         <span class="n">remove_total_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">to_final</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively pushes weights/labels towards initial or final states.</span>

<span class="sd">    This operation produces an equivalent transducer by pushing the weights</span>
<span class="sd">    and/or the labels towards the initial state or toward the final states.</span>

<span class="sd">    When pushing weights towards the initial state, the sum of the weight of the</span>
<span class="sd">    outgoing transitions and final weight at any non-initial state is equal to 1</span>
<span class="sd">    in the resulting machine. When pushing weights towards the final states, the</span>
<span class="sd">    sum of the weight of the incoming transitions at any state is equal to 1.</span>
<span class="sd">    Weights need to be left distributive when pushing towards the initial state</span>
<span class="sd">    and right distributive when pushing towards the final states.</span>

<span class="sd">    Pushing labels towards the initial state consists in minimizing at every</span>
<span class="sd">    state the length of the longest common prefix of the output labels of the</span>
<span class="sd">    outgoing paths. Pushing labels towards the final states consists in</span>
<span class="sd">    minimizing at every state the length of the longest common suffix of the</span>
<span class="sd">    output labels of the incoming paths.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        push_weights: Should weights be pushed?</span>
<span class="sd">        push_labels: Should labels be pushed?</span>
<span class="sd">        remove_common_affix: If pushing labels, should common prefix/suffix be</span>
<span class="sd">            removed?</span>
<span class="sd">        remove_total_weight: If pushing weights, should total weight be removed?</span>
<span class="sd">        to_final: Push towards final states?</span>
<span class="sd">        delta: Comparison/quantization delta (default: 0.0009765625).</span>

<span class="sd">    Returns:</span>
<span class="sd">        An equivalent pushed FST.</span>

<span class="sd">    See also: The destructive variant.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetPushFlags</span><span class="p">(</span><span class="n">push_weights</span><span class="p">,</span> <span class="n">push_labels</span><span class="p">,</span>
                                  <span class="n">remove_common_affix</span><span class="p">,</span> <span class="n">remove_total_weight</span><span class="p">)</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">push_cons</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
                        <span class="n">_getters</span><span class="o">.</span><span class="n">GetReweightType</span><span class="p">(</span><span class="n">to_final</span><span class="p">),</span> <span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="randequivalent"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.randequivalent">[docs]</a><span class="k">def</span> <span class="nf">randequivalent</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">npath</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">select</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="n">INT32_MAX</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Are two acceptors stochastically equivalent?</span>

<span class="sd">    This operation tests whether two FSTs are equivalent by randomly generating</span>
<span class="sd">    paths alternatively in each of the two FSTs. For each randomly generated</span>
<span class="sd">    path, the algorithm computes for each of the two FSTs the sum of the weights</span>
<span class="sd">    of all the successful paths sharing the same input and output labels as the</span>
<span class="sd">    randomly generated path and checks that these two values are within `delta`.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst1: The first input FST.</span>
<span class="sd">        ifst2: The second input FST.</span>
<span class="sd">        npath: The number of random paths to generate.</span>
<span class="sd">        delta: Comparison/quantization delta.</span>
<span class="sd">        seed: An optional seed value for random path generation; if None, the</span>
<span class="sd">            current time and process ID is used.</span>
<span class="sd">        select: A string matching a known random arc selection type; one of:</span>
<span class="sd">            &quot;uniform&quot;, &quot;log_prob&quot;, &quot;fast_log_prob&quot;.</span>
<span class="sd">        max_length: The maximum length of each random path.</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if the two transducers satisfy the above condition, else False.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: Random equivalence test encountered error.</span>

<span class="sd">    See also: `equal`, `equivalent`, `isomorphic`, `randgen`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetRandArcSelection</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown random arc selection type: </span><span class="si">{!r}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">select</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="n">ifst1</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">randequivalent</span><span class="p">(</span><span class="n">ifst1</span><span class="p">,</span> <span class="n">ifst2</span><span class="p">,</span> <span class="n">npath</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span>
                                              <span class="n">seed</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">max_length</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Random equivalence test encountered error&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="randgen"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.randgen">[docs]</a><span class="k">def</span> <span class="nf">randgen</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">npath</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
            <span class="n">max_length</span><span class="o">=</span><span class="n">INT32_MAX</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">remove_total_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly generate successful paths in an FST.</span>

<span class="sd">    This operation randomly generates a set of successful paths in the input</span>
<span class="sd">    FST. This relies on a mechanism for selecting arcs, specified using the</span>
<span class="sd">    `select` argument. The default selector, &quot;uniform&quot;, randomly selects a</span>
<span class="sd">    transition using a uniform distribution. The &quot;log_prob&quot; selector randomly</span>
<span class="sd">    selects a transition w.r.t. the weights treated as negative log</span>
<span class="sd">    probabilities after normalizing for the total weight leaving the state. In</span>
<span class="sd">    all cases, finality is treated as a transition to a super-final state.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        npath: The number of random paths to generate.</span>
<span class="sd">        seed: An optional seed value for random path generation; if zero, the</span>
<span class="sd">            current time and process ID is used.</span>
<span class="sd">        select: A string matching a known random arc selection type; one of:</span>
<span class="sd">            &quot;uniform&quot;, &quot;log_prob&quot;, &quot;fast_log_prob&quot;.</span>
<span class="sd">        max_length: The maximum length of each random path.</span>
<span class="sd">        weighted: Should the output be weighted by path count?</span>
<span class="sd">        remove_total_weight: Should the total weight be removed (ignored when</span>
<span class="sd">            `weighted` is False)?</span>

<span class="sd">    Returns:</span>
<span class="sd">        An FST containing one or more random paths.</span>

<span class="sd">    See also: `randequivalent`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetRandArcSelection</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown random arc selection type: </span><span class="si">{!r}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">select</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">randgen</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">max_length</span><span class="p">,</span>
                      <span class="n">npath</span><span class="p">,</span> <span class="n">weighted</span><span class="p">,</span> <span class="n">remove_total_weight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="replace"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.replace">[docs]</a><span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">root_label</span><span class="p">,</span> <span class="n">call_arc_labeling</span><span class="o">=</span><span class="s2">&quot;input&quot;</span><span class="p">,</span>
            <span class="n">return_arc_labeling</span><span class="o">=</span><span class="s2">&quot;neither&quot;</span><span class="p">,</span> <span class="n">epsilon_on_replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">return_label</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively replaces arcs in the root FST with other FST(s).</span>

<span class="sd">    This operation performs the dynamic replacement of arcs in one FST with</span>
<span class="sd">    another FST, allowing the definition of FSTs analogous to RTNs. It takes as</span>
<span class="sd">    input a set of pairs formed by a non-terminal label and its corresponding</span>
<span class="sd">    FST, and a label identifying the root FST in that set. The resulting FST is</span>
<span class="sd">    obtained by taking the root FST and recursively replacing each arc having a</span>
<span class="sd">    nonterminal as output label by its corresponding FST. More precisely, an arc</span>
<span class="sd">    from state s to state d with (nonterminal) output label n in this FST is</span>
<span class="sd">    replaced by redirecting this &quot;call&quot; arc to the initial state of a copy F of</span>
<span class="sd">    the FST for n, and adding &quot;return&quot; arcs from each final state of F to d.</span>
<span class="sd">    Optional arguments control how the call and return arcs are labeled; by</span>
<span class="sd">    default, the only non-epsilon label is placed on the call arc.</span>

<span class="sd">    Args:</span>
<span class="sd">        pairs: An iterable of (nonterminal label, FST) pairs, where the former</span>
<span class="sd">            is an unsigned integer and the latter is an Fst instance.</span>
<span class="sd">        root_label: Label identifying the root FST.</span>
<span class="sd">        call_arc_labeling: A string indicating which call arc labels should be</span>
<span class="sd">            non-epsilon. One of: &quot;input&quot; (default), &quot;output&quot;, &quot;both&quot;, &quot;neither&quot;.</span>
<span class="sd">            This value is set to &quot;neither&quot; if epsilon_on_replace is True.</span>
<span class="sd">        return_arc_labeling: A string indicating which return arc labels should</span>
<span class="sd">            be non-epsilon. One of: &quot;input&quot;, &quot;output&quot;, &quot;both&quot;, &quot;neither&quot;</span>
<span class="sd">            (default). This value is set to &quot;neither&quot; if epsilon_on_replace is</span>
<span class="sd">            True.</span>
<span class="sd">        epsilon_on_replace: Should call and return arcs be epsilon arcs? If</span>
<span class="sd">            True, this effectively overrides call_arc_labeling and</span>
<span class="sd">            return_arc_labeling, setting both to &quot;neither&quot;.</span>
<span class="sd">        return_label: The integer label for return arcs.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An FST resulting from expanding the input RTN.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">call_arc_labeling</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetReplaceLabelType</span><span class="p">(</span><span class="n">call_arc_labeling</span><span class="p">,</span>
                                                         <span class="n">epsilon_on_replace</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown call arc replace label type: </span><span class="si">{!r}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">call_arc_labeling</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">return_arc_labeling</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetReplaceLabelType</span><span class="p">(</span><span class="n">return_arc_labeling</span><span class="p">,</span>
                                                           <span class="n">epsilon_on_replace</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown return arc replace label type: </span><span class="si">{!r}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">return_arc_labeling</span><span class="p">))</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">ifst</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">pairs</span><span class="p">))</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">root_label</span><span class="p">,</span>
                      <span class="n">call_arc_labeling</span><span class="p">,</span> <span class="n">return_arc_labeling</span><span class="p">,</span> <span class="n">return_label</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="reverse"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.reverse">[docs]</a><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">require_superinitial</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively reverses an FST&#39;s transduction.</span>

<span class="sd">    This operation reverses an FST. If A transduces string x to y with weight a,</span>
<span class="sd">    then the reverse of A transduces the reverse of x to the reverse of y with</span>
<span class="sd">    weight a.Reverse(). (Typically, a = a.Reverse() and Arc = RevArc, e.g.,</span>
<span class="sd">    TropicalWeight and LogWeight.) In general, e.g., when the weights only form</span>
<span class="sd">    a left or right semiring, the output arc type must match the input arc type.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        require_superinitial: Should a superinitial state be created?</span>

<span class="sd">    Returns:</span>
<span class="sd">        A reversed FST.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">require_superinitial</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="rmepsilon"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.rmepsilon">[docs]</a><span class="k">def</span> <span class="nf">rmepsilon</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">queue_type</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
              <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nstate</span><span class="o">=</span><span class="n">NO_STATE_ID</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively removes epsilon transitions from an FST.</span>

<span class="sd">    This operation removes epsilon transitions (those where both input and</span>
<span class="sd">    output labels are epsilon) from an FST.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        connect: Should output be trimmed?</span>
<span class="sd">        reverse: Should epsilon transitions be removed in reverse order?</span>
<span class="sd">        queue_type: A string matching a known queue type; one of: &quot;auto&quot;,</span>
<span class="sd">            &quot;fifo&quot;, &quot;lifo&quot;, &quot;shortest&quot;, &quot;state&quot;, &quot;top&quot;.</span>
<span class="sd">        delta: Comparison/quantization delta (default: 0.0009765625).</span>
<span class="sd">        weight: A Weight in the FST semiring or an object that can be converted</span>
<span class="sd">            to a Weight in the FST semiring indicating the desired weight</span>
<span class="sd">            threshold; paths with weights below this threshold will be pruned.</span>
<span class="sd">        nstate: State number threshold (default: -1).</span>

<span class="sd">    Returns:</span>
<span class="sd">        An equivalent FST with no epsilon transitions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">queue_type</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetQueueType</span><span class="p">(</span><span class="n">queue_type</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown queue type: </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">queue_type</span><span class="p">))</span>
    <span class="c1"># Threshold is set to semiring Zero (no pruning) if weight is None.</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_weight_or_default</span><span class="p">(</span><span class="n">ifst</span><span class="o">.</span><span class="n">_weight_factory</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">rmepsilon_cons</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">connect</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span>
                             <span class="n">queue_type</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nstate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="shortestdistance"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.shortestdistance">[docs]</a><span class="k">def</span> <span class="nf">shortestdistance</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">NO_STATE_ID</span><span class="p">,</span>
                     <span class="n">queue_type</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the shortest distance from the initial or final state.</span>

<span class="sd">    This operation computes the shortest distance from the initial state (when</span>
<span class="sd">    `reverse` is False) or from every state to the final state (when `reverse`</span>
<span class="sd">    is True). The shortest distance from p to q is the \\otimes-sum of the</span>
<span class="sd">    weights of all the paths between p and q. The weights must be right (if</span>
<span class="sd">    `reverse` is False) or left (if `reverse` is True) distributive, and</span>
<span class="sd">    k-closed (i.e., 1 \\otimes x \\otimes x^2 \\otimes ... \\otimes x^{k + 1} = 1</span>
<span class="sd">    \\otimes x \\otimes x^2 \\otimes ... \\otimes x^k; e.g., TropicalWeight).</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        reverse: Should the reverse distance (from each state to the final</span>
<span class="sd">            state) be computed?</span>
<span class="sd">        source: Source state (this is ignored if `reverse` is True).</span>
<span class="sd">            If NO_STATE_ID (-1), use FST&#39;s initial state.</span>
<span class="sd">        queue_type: A string matching a known queue type; one of: &quot;auto&quot;,</span>
<span class="sd">            &quot;fifo&quot;, &quot;lifo&quot;, &quot;shortest&quot;, &quot;state&quot;, &quot;top&quot; (this is ignored if</span>
<span class="sd">            `reverse` is True).</span>
<span class="sd">        delta: Comparison/quantization delta (default: 0.0009765625).</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of Weight objects representing the shortest distance for each</span>
<span class="sd">        state.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">queue_type</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetQueueType</span><span class="p">(</span><span class="n">queue_type</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown queue type: </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">queue_type</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">shortestdistance</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">reverse</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">queue_type</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></div>


<div class="viewcode-block" id="shortestpath"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.shortestpath">[docs]</a><span class="k">def</span> <span class="nf">shortestpath</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">nshortest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">queue_type</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
                 <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nstate</span><span class="o">=</span><span class="n">NO_STATE_ID</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct an FST containing the shortest path(s) in the input FST.</span>

<span class="sd">    This operation produces an FST containing the n-shortest paths in the input</span>
<span class="sd">    FST. The n-shortest paths are the n-lowest weight paths w.r.t. the natural</span>
<span class="sd">    semiring order. The single path that can be read from the ith of at most n</span>
<span class="sd">    transitions leaving the initial state of the resulting FST is the ith</span>
<span class="sd">    shortest path. The weights need to be right distributive and have the path</span>
<span class="sd">    property. They also need to be left distributive as well for n-shortest with</span>
<span class="sd">    n &gt; 1 (e.g., TropicalWeight).</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        nshortest: The number of paths to return.</span>
<span class="sd">        unique: Should the resulting FST only contain distinct paths? (Requires</span>
<span class="sd">            the input FST to be an acceptor; epsilons are treated as if they are</span>
<span class="sd">            regular symbols.)</span>
<span class="sd">        queue_type: A string matching a known queue type; one of: &quot;auto&quot;,</span>
<span class="sd">            &quot;fifo&quot;, &quot;lifo&quot;, &quot;shortest&quot;, &quot;state&quot;, &quot;top&quot;.</span>
<span class="sd">        delta: Comparison/quantization delta (default: 0.0009765625).</span>
<span class="sd">        weight: A Weight in the FST semiring or an object that can be converted</span>
<span class="sd">            to a Weight in the FST semiring indicating the desired weight</span>
<span class="sd">            threshold below which paths are pruned; if omitted, no paths are</span>
<span class="sd">            pruned.</span>
<span class="sd">        nstate: State number threshold (default: -1).</span>

<span class="sd">    Returns:</span>
<span class="sd">        An FST containing the n-shortest paths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">queue_type</span> <span class="o">=</span> <span class="n">_getters</span><span class="o">.</span><span class="n">GetQueueType</span><span class="p">(</span><span class="n">queue_type</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown queue type: </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">queue_type</span><span class="p">))</span>
    <span class="c1"># Threshold is set to semiring Zero (no pruning) if weight is None.</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">_get_weight_or_default</span><span class="p">(</span><span class="n">ifst</span><span class="o">.</span><span class="n">_weight_factory</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">shortestpath</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">ofst</span><span class="p">,</span> <span class="n">nshortest</span><span class="p">,</span> <span class="n">unique</span><span class="p">,</span>
                           <span class="n">queue_type</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nstate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<div class="viewcode-block" id="statemap"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.statemap">[docs]</a><span class="k">def</span> <span class="nf">statemap</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">map_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively applies a transform to all states.</span>

<span class="sd">    This operation transforms each state according to the requested map type.</span>
<span class="sd">    Note that currently, only one state-mapping operation is supported.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>
<span class="sd">        map_type: A string matching a known mapping operation; one of:</span>
<span class="sd">            &quot;arc_sum&quot; (sum weights of identically-labeled multi-arcs),</span>
<span class="sd">            &quot;arc_unique&quot; (deletes non-unique identically-labeled multi-arcs).</span>

<span class="sd">    Returns:</span>
<span class="sd">        An FST with states remapped.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Unknown map type.</span>

<span class="sd">    See also: `arcmap`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">arcmap</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">DELTA</span><span class="p">,</span> <span class="n">map_type</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="synchronize"><a class="viewcode-back" href="../../../api/kaldi.fstext.html#kaldi.fstext.synchronize">[docs]</a><span class="k">def</span> <span class="nf">synchronize</span><span class="p">(</span><span class="n">ifst</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructively synchronizes an FST.</span>

<span class="sd">    This operation synchronizes a transducer. The result will be an equivalent</span>
<span class="sd">    FST that has the property that during the traversal of a path, the delay is</span>
<span class="sd">    either zero or strictly increasing, where the delay is the difference</span>
<span class="sd">    between the number of non-epsilon output labels and input labels along the</span>
<span class="sd">    path. For the algorithm to terminate, the input transducer must have bounded</span>
<span class="sd">    delay, i.e., the delay of every cycle must be zero.</span>

<span class="sd">    Args:</span>
<span class="sd">        ifst: The input FST.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An equivalent synchronized FST.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ofst</span> <span class="o">=</span> <span class="n">ifst</span><span class="o">.</span><span class="n">_mutable_fst_type</span><span class="p">()</span>
    <span class="n">ifst</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">synchronize</span><span class="p">(</span><span class="n">ifst</span><span class="p">,</span> <span class="n">ofst</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ofst</span></div>


<span class="c1">################################################################################</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;arcmap&#39;</span><span class="p">,</span> <span class="s1">&#39;compose&#39;</span><span class="p">,</span> <span class="s1">&#39;determinize&#39;</span><span class="p">,</span> <span class="s1">&#39;difference&#39;</span><span class="p">,</span> <span class="s1">&#39;disambiguate&#39;</span><span class="p">,</span>
    <span class="s1">&#39;epsnormalize&#39;</span><span class="p">,</span> <span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="s1">&#39;equivalent&#39;</span><span class="p">,</span> <span class="s1">&#39;intersect&#39;</span><span class="p">,</span> <span class="s1">&#39;isomorphic&#39;</span><span class="p">,</span>
    <span class="s1">&#39;prune&#39;</span><span class="p">,</span> <span class="s1">&#39;push&#39;</span><span class="p">,</span> <span class="s1">&#39;randequivalent&#39;</span><span class="p">,</span> <span class="s1">&#39;randgen&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="s1">&#39;reverse&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rmepsilon&#39;</span><span class="p">,</span> <span class="s1">&#39;shortestdistance&#39;</span><span class="p">,</span> <span class="s1">&#39;shortestpath&#39;</span><span class="p">,</span> <span class="s1">&#39;statemap&#39;</span><span class="p">,</span> <span class="s1">&#39;synchronize&#39;</span>
    <span class="p">]</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2018, Doan Can, Victor Martinez.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.0.9',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>