

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>kaldi.matrix &mdash; PyKaldi 0.0.9 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato" type="text/css" />
  
    <link rel="stylesheet" href="../../_static/pykaldi-theme.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="PyKaldi 0.0.9 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/pykaldi-logo-light.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../user/about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/install.html">Installation</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dev/conv.html">Coding Conventions</a></li>
</ul>
<p class="caption"><span class="caption-text">API Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.html">kaldi.asr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.base.html">kaldi.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.chain.html">kaldi.chain</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.cudamatrix.html">kaldi.cudamatrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.decoder.html">kaldi.decoder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.feat.html">kaldi.feat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.fstext.html">kaldi.fstext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.gmm.html">kaldi.gmm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.hmm.html">kaldi.hmm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.itf.html">kaldi.itf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.ivector.html">kaldi.ivector</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.kws.html">kaldi.kws</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.lat.html">kaldi.lat</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.lm.html">kaldi.lm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.matrix.html">kaldi.matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.nnet3.html">kaldi.nnet3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.online2.html">kaldi.online2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.rnnlm.html">kaldi.rnnlm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.sgmm2.html">kaldi.sgmm2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.tfrnnlm.html">kaldi.tfrnnlm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.transform.html">kaldi.transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.tree.html">kaldi.tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/kaldi.util.html">kaldi.util</a></li>
</ul>

            
          
    <p class="caption"><span class="caption-text">Other</span></p>
    <ul>
    <li class="toctree-l1"><a href="../../genindex.html">Index</a></li>
    </ul>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyKaldi</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>kaldi.matrix</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for kaldi.matrix</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">PyKaldi defines the following CPU vector/matrix types:</span>

<span class="sd">================= ====================== ============================ =========================</span>
<span class="sd">Type              32-bit floating point  64-bit floating point        Other</span>
<span class="sd">================= ====================== ============================ =========================</span>
<span class="sd">Dense Matrix      :class:`.Matrix`       :class:`.DoubleMatrix`       :class:`.CompressedMatrix`</span>
<span class="sd">Dense Vector      :class:`.Vector`       :class:`.DoubleVector`</span>
<span class="sd">Symmetric Matrix  :class:`.SpMatrix`     :class:`.DoubleSpMatrix`</span>
<span class="sd">Triangular Matrix :class:`.TpMatrix`     :class:`.DoubleTpMatrix`</span>
<span class="sd">Sparse Matrix     :class:`.SparseMatrix` :class:`.DoubleSparseMatrix`</span>
<span class="sd">Sparse Vector     :class:`.SparseVector` :class:`.DoubleSparseMatrix`</span>
<span class="sd">================= ====================== ============================ =========================</span>

<span class="sd">In addition, there is a :class:`.GeneralMatrix` type which is a wrapper around</span>
<span class="sd">:class:`.Matrix`, :class:`.SparseMatrix` and :class:`.CompressedMatrix` types.</span>

<span class="sd">The dense :class:`Vector`/:class:`Matrix` types come in two flavors.</span>

<span class="sd">:class:`Vector`/:class:`Matrix` instances own the memory buffers backing them.</span>
<span class="sd">Instantiating a new :class:`Vector`/:class:`Matrix` object allocates new memory</span>
<span class="sd">for storing the elements. They support destructive operations that reallocate</span>
<span class="sd">memory.</span>

<span class="sd">:class:`SubVector`/:class:`SubMatrix` instances, on the other hand, share the</span>
<span class="sd">memory buffers owned by other objects. Instantiating a new</span>
<span class="sd">:class:`SubVector`/:class:`SubMatrix` object does not allocate new memory. Since</span>
<span class="sd">they provide views into other existing objects, they do not support destructive</span>
<span class="sd">operations that reallocate memory. Other than this caveat, they are equivalent</span>
<span class="sd">to :class:`Vector`/:class:`Matrix` instances for all practical purposes. Almost</span>
<span class="sd">any function or method accepting a :class:`Vector`/:class:`Matrix` instance can</span>
<span class="sd">instead be passed a :class:`SubVector`/:class:`SubMatrix` instance.</span>

<span class="sd">.. note::</span>
<span class="sd">    All mutating vector/matrix methods are marked with an underscore suffix.</span>
<span class="sd">    These methods overwrite the contents and return the resulting object,</span>
<span class="sd">    unless they have other return values, to support method chaining.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_compressed_matrix</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_kaldi_matrix</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_kaldi_matrix_ext</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_kaldi_vector</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_kaldi_vector_ext</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_matrix_ext</span>
<span class="kn">import</span> <span class="nn">_matrix_common</span>  <span class="c1"># FIXME: Relative/absolute import is buggy in Python 3.</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_packed_matrix</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_sp_matrix</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_tp_matrix</span>
<span class="kn">from</span> <span class="nn">._str</span> <span class="k">import</span> <span class="n">set_printoptions</span>


<span class="c1">################################################################################</span>
<span class="c1"># single precision vector/matrix types</span>
<span class="c1">################################################################################</span>


<span class="k">class</span> <span class="nc">_VectorBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the additional API for single precision vectors.</span>

<span class="sd">    No constructor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">copy_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from another vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            src (Vector or DoubleVector): The input vector.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">src</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vector of size </span><span class="si">{}</span><span class="s2"> cannot be copied into vector &quot;</span>
                             <span class="s2">&quot;of size </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_from_vec_</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_from_double_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input vector type is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clones the vector.</span>

<span class="sd">        The clone allocates new memory for its contents and supports vector</span>
<span class="sd">        operations that reallocate memory, i.e. it is not a view.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vector: A copy of the vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the size of the vector as a single element tuple.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Single element tuple representing the size of the vector.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">approx_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if vectors are approximately equal.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (Vector): The vector to compare against.</span>
<span class="sd">            tol (float): The tolerance for the equality check.</span>
<span class="sd">                Defaults to ``0.01``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if `self.dim == other.dim` and</span>
<span class="sd">            `||self-other|| &lt;= tol*||self||`. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_approx_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">approx_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the vector to a 1-D NumPy array.</span>

<span class="sd">        The NumPy array is a view into the vector, i.e. no data is copied.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A NumPy array sharing data with this vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_matrix_ext</span><span class="o">.</span><span class="n">vector_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector data as a memoryview.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the given range of elements as a new vector view.</span>

<span class="sd">        Args:</span>
<span class="sd">            start (int): The start index.</span>
<span class="sd">            length (int): The length.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SubVector: A vector view representing the given range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SubVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_vec_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds another vector.</span>

<span class="sd">        Performs the operation :math:`y = y + \\alpha\\ v`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier.</span>
<span class="sd">            v (Vector or DoubleVector): The input vector.</span>

<span class="sd">        Raises:</span>
<span class="sd">          RuntimeError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_vec_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_double_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input vector type is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_vec2_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the squares of elements from another vector.</span>

<span class="sd">        Performs the operation :math:`y = y + \\alpha\\ v\\odot v`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier.</span>
<span class="sd">            v (Vector or DoubleVector): The input vector.</span>

<span class="sd">        Raises:</span>
<span class="sd">          RuntimeError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_vec2_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_double_vec2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input vector type is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_mat_vec_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes a matrix-vector product.</span>

<span class="sd">        Performs the operation :math:`y = \\alpha\\ M\\ v + \\beta\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier for the matrix-vector product.</span>
<span class="sd">            M (Matrix or SpMatrix or TpMatrix): The input matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **M** or its transpose.</span>
<span class="sd">            v (Vector): The input vector.</span>
<span class="sd">            beta (int): The scalar multiplier for the destination vector.</span>
<span class="sd">            sparse (bool): Whether to use the algorithm that is faster when</span>
<span class="sd">                **v** is sparse. Defaults to ``False``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix of size </span><span class="si">{}</span><span class="s2">x</span><span class="si">{}</span><span class="s2"> cannot be multiplied with &quot;</span>
                             <span class="s2">&quot;vector of size </span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vector of size </span><span class="si">{}</span><span class="s2"> cannot be added to vector of &quot;</span>
                             <span class="s2">&quot;size </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_mat_svec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_mat_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_sp_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">TpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_tp_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">mul_tp_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiplies the vector with a lower-triangular matrix.</span>

<span class="sd">        Performs the operation :math:`y = M\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (TpMatrix): The input lower-triangular matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **M** or its transpose.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix with size </span><span class="si">{}</span><span class="s2">x</span><span class="si">{}</span><span class="s2"> cannot be multiplied &quot;</span>
                             <span class="s2">&quot;with vector of size </span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_mul_tp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">solve_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves a linear system.</span>

<span class="sd">        The linear system is defined as :math:`M\\ x = b`, where :math:`b` and</span>
<span class="sd">        :math:`x` are the initial and final values of the vector, respectively.</span>

<span class="sd">        Warning:</span>
<span class="sd">            Does not test for :math:`M` being singular or near-singular.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (TpMatrix): The input lower-triangular matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **M** or its transpose.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of rows of the input matrix (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                             <span class="s2">&quot;should match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_rows_from_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from a matrix row-by-row.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (Matrix or DoubleMatrix): The input matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">*</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of elements of the input matrix (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                             <span class="s2">&quot;should match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">*</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_rows_from_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_rows_from_double_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_cols_from_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from a matrix column-by-columm.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (Matrix): The input matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">*</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of elements of the input matrix (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                             <span class="s2">&quot;should match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">*</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_cols_from_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_row_from_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from a matrix row.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (Matrix or DoubleMatrix or SpMatrix or DoubleSpMatrix):</span>
<span class="sd">                The input matrix.</span>
<span class="sd">            row (int): The row index.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">            IndexError: If the row index is out-of-bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of columns of the input matrix (</span><span class="si">{}</span><span class="s2">)&quot;</span>
                             <span class="s2">&quot;should match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_row_from_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_row_from_double_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_row_from_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">DoubleSpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_row_from_double_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_col_from_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from a matrix column.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (Matrix or DoubleMatrix): The input matrix.</span>
<span class="sd">            col (int): The column index.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">            IndexError: If the column index is out-of-bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of rows of the input matrix (</span><span class="si">{}</span><span class="s2">)&quot;</span>
                             <span class="s2">&quot;should match the size of this vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">instance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_col_from_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_col_from_double_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_diag_from_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the digonal elements from a matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (Matrix or SpMatrix or TpMatrix): The input matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="nb">min</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The size of the matrix diagonal (</span><span class="si">{}</span><span class="s2">) should &quot;</span>
                             <span class="s2">&quot;match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_diag_from_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_diag_from_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">TpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_diag_from_tp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_from_packed_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from a packed matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (SpMatrix or TpMatrix or DoubleSpMatrix or DoubleTpMatrix):</span>
<span class="sd">                The input packed matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `self.dim !=  M.num_rows * (M.num_rows + 1) / 2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numel</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">numel</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of elements of the input packed matrix&quot;</span>
                             <span class="s2">&quot; (</span><span class="si">{}</span><span class="s2">) should match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_packed_matrix</span><span class="o">.</span><span class="n">PackedMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_from_packed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_packed_matrix</span><span class="o">.</span><span class="n">DoublePackedMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_from_double_packed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_row_sum_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the sum of matrix rows.</span>

<span class="sd">        Performs the operation :math:`y = \\alpha\\ \\sum_i M[i] + \\beta\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier for the row sum.</span>
<span class="sd">            M (Matrix): The input matrix.</span>
<span class="sd">            beta (float): The scalar multiplier for the destination vector.</span>
<span class="sd">                Defaults to ``1.0``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `self.dim != M.num_cols`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot add sum of rows with size </span><span class="si">{}</span><span class="s2"> to &quot;</span>
                             <span class="s2">&quot;vector of size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_row_sum_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_col_sum_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the sum of matrix columns.</span>

<span class="sd">        Performs the operation</span>
<span class="sd">        :math:`y = \\alpha\\ \\sum_i M[:,i] + \\beta\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier for the column sum.</span>
<span class="sd">            M (Matrix): The input matrix.</span>
<span class="sd">            beta (float): The scalar multiplier for the destination vector.</span>
<span class="sd">                Defaults to ``1.0``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `self.dim != M.num_rows`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot add sum of columns with size </span><span class="si">{}</span><span class="s2"> to &quot;</span>
                             <span class="s2">&quot;vector of size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_col_sum_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_diag_mat2_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span>
                       <span class="n">trans</span><span class="o">=</span><span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">,</span>
                       <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the diagonal of a matrix multiplied with its transpose.</span>

<span class="sd">        Performs the operation :math:`y = \\alpha\\ diag(M M^T) + \\beta\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier for the diagonal.</span>
<span class="sd">            M (Matrix): The input matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **M** or its transpose.</span>
<span class="sd">                Defaults to ``MatrixTransposeType.NO_TRANS``.</span>
<span class="sd">            beta (float): The scalar multiplier for the destination vector.</span>
<span class="sd">                Defaults to ``1.0``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot add diagonal with size </span><span class="si">{}</span><span class="s2"> to &quot;</span>
                             <span class="s2">&quot;vector of size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_diag_mat2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_diag_mat_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">transM</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">transN</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the diagonal of a matrix-matrix product.</span>

<span class="sd">        Performs the operation :math:`y = \\alpha\\ diag(M N) + \\beta\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier for the diagonal.</span>
<span class="sd">            M (Matrix): The first input matrix.</span>
<span class="sd">            transM (MatrixTransposeType): Whether to use **M** or its transpose.</span>
<span class="sd">            N (Matrix): The second input matrix.</span>
<span class="sd">            transN (MatrixTransposeType): Whether to use **N** or its transpose.</span>
<span class="sd">            beta (float): The scalar multiplier for the destination vector.</span>
<span class="sd">                Defaults to ``1.0``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">transM</span> <span class="o">==</span> <span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transN</span> <span class="o">==</span> <span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">p</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply M (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">) with &quot;</span>
                                     <span class="s2">&quot;N (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">q</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply M (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">) with &quot;</span>
                                     <span class="s2">&quot;N^T (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transN</span> <span class="o">==</span> <span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">p</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply M (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">) with &quot;</span>
                                     <span class="s2">&quot;N (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">q</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply M (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">) with &quot;</span>
                                     <span class="s2">&quot;N (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_diag_mat_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">transM</span><span class="p">,</span>
                                            <span class="n">N</span><span class="p">,</span> <span class="n">transN</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mul_elements_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiplies the elements with the elements of another vector.</span>

<span class="sd">        Performs the operation `y[i] *= v[i]`.</span>

<span class="sd">        Args:</span>
<span class="sd">            v (Vector or DoubleVector): The input vector.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mul_elements_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_mul_double_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input vector type is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">div_elements_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Divides the elements with the elements of another vector.</span>

<span class="sd">        Performs the operation `y[i] /= v[i]`.</span>

<span class="sd">        Args:</span>
<span class="sd">            v (Vector or DoubleVector): The input vector.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_div_elements_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_div_double_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input vector type is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># All strings are unicode in Python 3, while we have to encode unicode</span>
        <span class="c1"># strings in Python2. If we can&#39;t, let python decide the best</span>
        <span class="c1"># characters to replace unicode characters with.</span>
        <span class="c1"># Below implementation was taken from</span>
        <span class="c1"># https://github.com/pytorch/pytorch/blob/master/torch/tensor.py</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
            <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_vector_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="s1">&#39;encoding&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_vector_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">or</span> <span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_vector_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements self[index].</span>

<span class="sd">        This operation is offloaded to NumPy. Hence, it supports all NumPy array</span>
<span class="sd">        indexing schemes: field access, basic slicing and advanced indexing.</span>
<span class="sd">        For details see `NumPy Array Indexing`_.</span>

<span class="sd">        Slicing shares data with the source vector when possible (see Caveats).</span>

<span class="sd">        Returns:</span>
<span class="sd">            - a float if the result of numpy indexing is a scalar</span>
<span class="sd">            - a SubVector if the result of numpy indexing is 1 dimensional</span>
<span class="sd">            - a SubMatrix if the result of numpy indexing is 2 dimensional</span>

<span class="sd">        Caveats:</span>
<span class="sd">            - Kaldi vector and matrix types do not support non-contiguous memory</span>
<span class="sd">              layouts for the last dimension, i.e. the stride for the last</span>
<span class="sd">              dimension should be the size of a float. If the result of numpy</span>
<span class="sd">              slicing operation has an unsupported stride value for the last</span>
<span class="sd">              dimension, the return value will not share any data with the</span>
<span class="sd">              source vector, i.e. a copy will be made. Consider the following:</span>
<span class="sd">                &gt;&gt;&gt; v = Vector(5)</span>
<span class="sd">                &gt;&gt;&gt; s = v[0:4:2]     # s does not share data with v</span>
<span class="sd">                &gt;&gt;&gt; s[:] = v[1:4:2]  # changing s will not change v</span>
<span class="sd">              Since the slicing operation requires a copy of the data to be</span>
<span class="sd">              made, the source vector v will not be updated. On the other hand,</span>
<span class="sd">              the following assignment operation will work as expected since</span>
<span class="sd">              __setitem__ method does not create a new vector for representing</span>
<span class="sd">              the left hand side:</span>
<span class="sd">                &gt;&gt;&gt; v[0:4:2] = v[1:4:2]</span>

<span class="sd">        .. _NumPy Array Indexing:</span>
<span class="sd">            https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SubVector</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SubMatrix</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indexing operation returned a numpy array &quot;</span>
                                 <span class="s2">&quot; with </span><span class="si">{}</span><span class="s2"> dimensions.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indexing operation returned an invalid type </span><span class="si">{}</span><span class="s2">.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ret</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements self[index] = value.</span>

<span class="sd">        This operation is offloaded to NumPy. Hence, it supports all NumPy array</span>
<span class="sd">        indexing schemes: field access, basic slicing and advanced indexing.</span>
<span class="sd">        For details see `NumPy Array Indexing`_.</span>

<span class="sd">        .. _NumPy Array Indexing:</span>
<span class="sd">            https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># Numpy array interface methods were adapted from PyTorch.</span>
    <span class="c1"># https://github.com/pytorch/pytorch/commit/c488a9e9bf9eddca6d55957304612b88f4638ca7</span>

    <span class="c1"># Numpy array interface, to support `numpy.asarray(vector) -&gt; ndarray`</span>
    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Wrap Numpy array in a vector or matrix when done, to support e.g.</span>
    <span class="c1"># `numpy.sin(vector) -&gt; vector` or `numpy.greater(vector, 0) -&gt; vector`</span>
    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;bad scalar </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
                <span class="c1"># Vector stores single precision floats.</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">SubVector</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
                <span class="c1"># Matrix stores single precision floats.</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">SubMatrix</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> dimensional array cannot be converted to a &#39;</span>
                               <span class="s1">&#39;vector or matrix type&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>


<div class="viewcode-block" id="Vector"><a class="viewcode-back" href="../../api/kaldi.matrix.html#kaldi.matrix.Vector">[docs]</a><span class="k">class</span> <span class="nc">Vector</span><span class="p">(</span><span class="n">_VectorBase</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Single precision vector.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Vector():</span>
<span class="sd">            Creates an empty vector.</span>

<span class="sd">        Vector(size: int):</span>
<span class="sd">            Creates a new vector of given size and fills it with zeros.</span>

<span class="sd">        Args:</span>
<span class="sd">            size (int): Size of the new vector.</span>

<span class="sd">        Vector(obj: vector_like):</span>
<span class="sd">            Creates a new vector with the elements in obj.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (vector_like): A vector, a 1-D numpy array, any object exposing</span>
<span class="sd">                a 1-D array interface, an object with an __array__ method</span>
<span class="sd">                returning a 1-D numpy array, or any sequence that can be</span>
<span class="sd">                interpreted as a vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;__init__() takes 1 to 2 positional arguments but &quot;</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> were given&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Vector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size should non-negative&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">,</span>
                                <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">)):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;obj should be a 1-D vector like object.&quot;</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">SubVector</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixResizeType</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes an element from the vector.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;index=</span><span class="si">{}</span><span class="s2"> should be in the range [0,</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_element_</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="SubVector"><a class="viewcode-back" href="../../api/kaldi.matrix.html#kaldi.matrix.SubVector">[docs]</a><span class="k">class</span> <span class="nc">SubVector</span><span class="p">(</span><span class="n">_VectorBase</span><span class="p">,</span> <span class="n">_matrix_ext</span><span class="o">.</span><span class="n">SubVector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Single precision vector view.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new vector view from a vector like object.</span>

<span class="sd">        If possible the new vector view will share its data with the `obj`,</span>
<span class="sd">        i.e. no copy will be made. A copy will only be made if `obj.__array__`</span>
<span class="sd">        returns a copy, if `obj` is a sequence, or if a copy is needed to</span>
<span class="sd">        satisfy any of the other requirements (data type, order, etc.).</span>
<span class="sd">        Regardless of whether a copy is made or not, the new vector view will</span>
<span class="sd">        not own the memory buffer backing it, i.e. it will not support vector</span>
<span class="sd">        operations that reallocate memory.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (vector_like): A vector, a 1-D numpy array, any object exposing</span>
<span class="sd">                a 1-D array interface, an object whose __array__ method returns</span>
<span class="sd">                a 1-D numpy array, or any sequence that can be interpreted as a</span>
<span class="sd">                vector.</span>
<span class="sd">            start (int): The index of the view start. Defaults to 0.</span>
<span class="sd">            length (int): The length of the view. If None, it is set to</span>
<span class="sd">                len(obj) - start. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;obj should be a 1-D vector like object.&quot;</span><span class="p">)</span>
        <span class="n">obj_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">obj_len</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;start=</span><span class="si">{0}</span><span class="s2"> should be in the range [0,</span><span class="si">{1}</span><span class="s2">] &quot;</span>
                             <span class="s2">&quot;when len(obj)=</span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">obj_len</span><span class="p">))</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="n">obj_len</span> <span class="o">-</span> <span class="n">start</span>
        <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">max_len</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">max_len</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;length=</span><span class="si">{}</span><span class="s2"> should be in the range [0,</span><span class="si">{}</span><span class="s2">] when &quot;</span>
                             <span class="s2">&quot;start=</span><span class="si">{}</span><span class="s2"> and len(obj)=</span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">max_len</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">obj_len</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SubVector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_MatrixBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the additional API for single precision matrices.</span>

<span class="sd">    No constructor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">copy_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from another matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">            src(Matrix or SpMatrix or TpMatrix or DoubleMatrix or DoubleSpMatrix or DoubleTpMatrix or CompressedMatrix):</span>
<span class="sd">                The input matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **src** or its transpose.</span>
<span class="sd">                Defaults to ``MatrixTransposeType.NO_TRANS``. Not active if</span>
<span class="sd">                input is a compressed matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">src</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot copy matrix with dimensions </span><span class="si">{s[0]}</span><span class="s2">x</span><span class="si">{s[1]}</span><span class="s2"> &quot;</span>
                             <span class="s2">&quot;into matrix with dimensions </span><span class="si">{d[0]}</span><span class="s2">x</span><span class="si">{d[1]}</span><span class="s2">&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_copy_from_mat_</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">TpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_tp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_double_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_double_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">TpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_double_tp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_compressed_matrix</span><span class="o">.</span><span class="n">CompressedMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_cmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clones the matrix.</span>

<span class="sd">        The clone allocates new memory for its contents and supports matrix</span>
<span class="sd">        operations that reallocate memory, i.e. it is not a view.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Matrix: A copy of the matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the size of the matrix.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple (num_rows, num_cols) of integers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Two element tuple representing the size of the matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">approx_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if matrices are approximately equal.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (Matrix): The matrix to compare against.</span>
<span class="sd">            tol (float): The tolerance for the equality check.</span>
<span class="sd">                Defaults to ``0.01``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if `self.size() == other.size()` and</span>
<span class="sd">            `||self-other|| &lt;= tol*||self||`. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">num_rows</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_approx_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">approx_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the matrix to a 2-D NumPy array.</span>

<span class="sd">        The NumPy array is a view into the matrix, i.e. no data is copied.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A NumPy array sharing data with this matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_matrix_ext</span><span class="o">.</span><span class="n">matrix_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Matrix data as a memoryview.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">row_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns row data as a memoryview.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the given row as a new vector view.</span>

<span class="sd">        Args:</span>
<span class="sd">            index (int): The row index.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SubVector: A vector view representing the given row.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">col_start</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the given range of elements as a new matrix view.</span>

<span class="sd">        Args:</span>
<span class="sd">            row_start (int): The start row index.</span>
<span class="sd">            num_rows (int): The number of rows.</span>
<span class="sd">            col_start (int): The start column index.</span>
<span class="sd">            num_cols (int): The number of columns.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SubMatrix: A matrix view representing the given range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SubMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">col_start</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">row_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the given range of rows as a new matrix view.</span>

<span class="sd">        Args:</span>
<span class="sd">            row_start (int): The start row index.</span>
<span class="sd">            num_rows (int): The number of rows.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SubMatrix: A matrix view representing the given row range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SubMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">col_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_start</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the given range of columns as a new matrix view.</span>

<span class="sd">        Args:</span>
<span class="sd">            col_start (int): The start column index.</span>
<span class="sd">            num_cols (int): The number of columns.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SubMatrix: A matrix view representing the given column range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SubMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">col_start</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eig</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes eigendecomposition.</span>

<span class="sd">        Factorizes a square matrix into :math:`P\\ D\\ P^{-1}`.</span>

<span class="sd">        The relationship of :math:`D` to the eigenvalues is slightly</span>
<span class="sd">        complicated, due to the need for :math:`P` to be real. In the symmetric</span>
<span class="sd">        case, :math:`D` is diagonal and real, but in the non-symmetric case</span>
<span class="sd">        there may be complex-conjugate pairs of eigenvalues. In this case, for</span>
<span class="sd">        the equation :math:`y = P\\ D\\ P^{-1}` to hold, :math:`D` must actually</span>
<span class="sd">        be block diagonal, with 2x2 blocks corresponding to any such pairs. If a</span>
<span class="sd">        pair is :math:`\\lambda +- i\\mu`, :math:`D` will have a corresponding</span>
<span class="sd">        2x2 block :math:`[\\lambda, \\mu; -\\mu, \\lambda]`. Note that if the</span>
<span class="sd">        matrix is not invertible, :math:`P` may not be invertible so in this</span>
<span class="sd">        case instead of the equation :math:`y = P\\ D\\ P^{-1}` holding, we have</span>
<span class="sd">        :math:`y\\ P = P\\ D`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            3-element tuple containing</span>

<span class="sd">            - **P** (:class:`Matrix`): The eigenvector matrix, where ith column</span>
<span class="sd">              corresponds to the ith eigenvector.</span>
<span class="sd">            - **r** (:class:`Vector`): The vector with real components of the</span>
<span class="sd">              eigenvalues.</span>
<span class="sd">            - **i** (:class:`Vector`): The vector with imaginary components of</span>
<span class="sd">              the eigenvalues.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the matrix is not square.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;eig method cannot be called on a non-square &quot;</span>
                             <span class="s2">&quot;matrix.&quot;</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">Vector</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eig</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">svd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destructive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes singular-value decomposition.</span>

<span class="sd">        Factorizes a matrix into :math:`U\\ diag(s)\\ V^T`.</span>

<span class="sd">        For non-square matrices, requires `self.num_rows &gt;= self.num_cols`.</span>

<span class="sd">        Args:</span>
<span class="sd">            destructive (bool): Whether to use the destructive operation which</span>
<span class="sd">                avoids a copy but mutates self. Defaults to ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            3-element tuple containing</span>

<span class="sd">            - **s** (:class:`Vector`): The vector of singular values.</span>
<span class="sd">            - **U** (:class:`Matrix`): The left orthonormal matrix.</span>
<span class="sd">            - **Vt** (:class:`Matrix`): The right orthonormal matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `self.num_rows &lt; self.num_cols`.</span>

<span class="sd">        Note:</span>
<span class="sd">          **Vt** in the output is already transposed.</span>
<span class="sd">          The singular values in **s** are not sorted.</span>

<span class="sd">        See Also:</span>
<span class="sd">          :meth:`singular_values`</span>
<span class="sd">          :meth:`sort_svd`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;svd for non-square matrices requires &quot;</span>
                             <span class="s2">&quot;self.num_rows &gt;= self.num_cols.&quot;</span><span class="p">)</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">destructive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_destructive_svd_</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Vt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_svd</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Vt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Vt</span>

    <span class="k">def</span> <span class="nf">singular_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes singular values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Vector: The vector of singular values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_singular_values</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">add_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span>
                 <span class="n">trans</span><span class="o">=</span><span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds another matrix to this one.</span>

<span class="sd">        Performs the operation :math:`S = \\alpha\\ M + S`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier.</span>
<span class="sd">            M (Matrix or SpMatrix or DoubleSpMatrix): The input matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **M** or its transpose.</span>
<span class="sd">                Defaults to ``MatrixTransposeType.NO_TRANS``.</span>

<span class="sd">        Raises:</span>
<span class="sd">          RuntimeError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_mat_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">add_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">DoubleSpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">add_double_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_mat_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span>
                     <span class="n">transA</span><span class="o">=</span><span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">,</span>
                     <span class="n">transB</span><span class="o">=</span><span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">,</span>
                     <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sparseA</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparseB</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the product of given matrices.</span>

<span class="sd">        Performs the operation :math:`M = \\alpha\\ A\\ B + \\beta\\ M`.</span>

<span class="sd">        Args:</span>
<span class="sd">            A (Matrix or TpMatrix or SpMatrix):</span>
<span class="sd">                The first input matrix.</span>
<span class="sd">            B (Matrix or TpMatrix or SpMatrix):</span>
<span class="sd">                The second input matrix.</span>
<span class="sd">            transA (MatrixTransposeType): Whether to use **A** or its transpose.</span>
<span class="sd">                Defaults to ``MatrixTransposeType.NO_TRANS``.</span>
<span class="sd">            transB (MatrixTransposeType): Whether to use **B** or its transpose.</span>
<span class="sd">                Defaults to ``MatrixTransposeType.NO_TRANS``.</span>
<span class="sd">            alpha (float): The scalar multiplier for the product.</span>
<span class="sd">                Defaults to ``1.0``.</span>
<span class="sd">            beta (float): The scalar multiplier for the destination vector.</span>
<span class="sd">                Defaults to ``1.0``.</span>
<span class="sd">            sparseA (bool): Whether to use the algorithm that is faster when</span>
<span class="sd">                **A** is sparse. Defaults to ``False``.</span>
<span class="sd">            sparseA (bool): Whether to use the algorithm that is faster when</span>
<span class="sd">                **B** is sparse. Defaults to ``False``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: In case of size mismatch.</span>
<span class="sd">            TypeError: If matrices of given types can not be multiplied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sparseA</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_smat_mat_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">sparseB</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_mat_smat_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_mat_mat_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_mat_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">TpMatrix</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_mat_tp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span>
                                              <span class="n">beta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply matrix A with matrix B of &quot;</span>
                                <span class="s2">&quot;type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_sp_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_sp_sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply symmetric matrix A with &quot;</span>
                                <span class="s2">&quot;matrix B of type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_tp_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span>
                                              <span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">TpMatrix</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_tp_tp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span>
                                             <span class="n">beta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply triangular matrix A with &quot;</span>
                                <span class="s2">&quot;matrix B of type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">invert_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_double_precision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverts the matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">            in_double_precision (bool): Whether to do the inversion in double</span>
<span class="sd">                precision. Defaults to ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            2-element tuple containing</span>

<span class="sd">            - **log_det** (:class:`float`): The log determinant.</span>
<span class="sd">            - **det_sign** (:class:`float`): The sign of the determinant, 1 or -1.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If matrix is not square.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">in_double_precision</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_invert_in_double</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_invert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy_cols_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies columns from another matrix.</span>

<span class="sd">        Copies column `r` from column `indices[r]` of `src`. As a special case,</span>
<span class="sd">        if `indexes[i] == -1`, sets column `i` to zero. All elements of indices</span>
<span class="sd">        must be in `[-1, src.num_cols-1]`, and `src.num_rows` must equal</span>
<span class="sd">        `self.num_rows`.</span>

<span class="sd">        Args:</span>
<span class="sd">            src (Matrix): The input matrix.</span>
<span class="sd">            indices (List[int]): The list of column indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_rows_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies rows from another matrix.</span>

<span class="sd">        Copies row `r` from row `indices[r]` of `src`. As a special case, if</span>
<span class="sd">        `indexes[i] == -1`, sets row `i` to zero. All elements of indices must</span>
<span class="sd">        be in `[-1, src.num_rows-1]`, and `src.num_cols` must equal</span>
<span class="sd">        `self.num_cols`.</span>

<span class="sd">        Args:</span>
<span class="sd">            src (Matrix): The input matrix.</span>
<span class="sd">            indices (List[int]): The list of row indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_cols_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds columns from another matrix.</span>

<span class="sd">        Adds column `indices[r]` of `src` to column `r`. As a special case, if</span>
<span class="sd">        `indexes[i] == -1`, skips column `i`. All elements of indices must be in</span>
<span class="sd">        `[-1, src.num_cols-1]`, and `src.num_rows` must equal `self.num_rows`.</span>

<span class="sd">        Args:</span>
<span class="sd">            src (Matrix): The input matrix.</span>
<span class="sd">            indices (List[int]): The list of column indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_rows_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds rows from another matrix.</span>

<span class="sd">        Scales row `indices[r]` of `src` with `alpha` and adds it to row `r`. As</span>
<span class="sd">        a special case, if `indexes[i] == -1`, skips row `i`. All elements of</span>
<span class="sd">        indices must be in `[-1, src.num_rows-1]`, and `src.num_cols` must equal</span>
<span class="sd">        `self.num_cols`.</span>

<span class="sd">        Args:</span>
<span class="sd">            src (Matrix): The input matrix.</span>
<span class="sd">            indices (List[int]): The list of row indices.</span>
<span class="sd">            alpha (float): The scalar multiplier. Defaults to `1.0`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements self[index].</span>

<span class="sd">        This operation is offloaded to NumPy. Hence, it supports all NumPy array</span>
<span class="sd">        indexing schemes: field access, basic slicing and advanced indexing.</span>
<span class="sd">        For details see `NumPy Array Indexing`_.</span>

<span class="sd">        Slicing shares data with the source matrix when possible (see Caveats).</span>

<span class="sd">        Returns:</span>
<span class="sd">            - a float if the result of numpy indexing is a scalar</span>
<span class="sd">            - a SubVector if the result of numpy indexing is 1 dimensional</span>
<span class="sd">            - a SubMatrix if the result of numpy indexing is 2 dimensional</span>

<span class="sd">        Caveats:</span>
<span class="sd">            - Kaldi vector and matrix types do not support non-contiguous memory</span>
<span class="sd">              layouts for the last dimension, i.e. the stride for the last</span>
<span class="sd">              dimension should be the size of a float. If the result of numpy</span>
<span class="sd">              slicing operation has an unsupported stride value for the last</span>
<span class="sd">              dimension, the return value will not share any data with the</span>
<span class="sd">              source matrix, i.e. a copy will be made. Consider the following:</span>
<span class="sd">                &gt;&gt;&gt; m = Matrix(3, 5)</span>
<span class="sd">                &gt;&gt;&gt; s = m[:,0:4:2]     # s does not share data with m</span>
<span class="sd">                &gt;&gt;&gt; s[:] = m[:,1:4:2]  # changing s will not change m</span>
<span class="sd">              Since the slicing operation requires a copy of the data to be</span>
<span class="sd">              made, the source matrix m will not be updated. On the other hand,</span>
<span class="sd">              the following assignment operation will work as expected since</span>
<span class="sd">              __setitem__ method does not create a new scalar/vector/matrix for</span>
<span class="sd">              representing the left hand side:</span>
<span class="sd">                &gt;&gt;&gt; m[:,0:4:2] = m[:,1:4:2]</span>

<span class="sd">        .. _NumPy Array Indexing:</span>
<span class="sd">            https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SubMatrix</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SubVector</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indexing operation returned a numpy array &quot;</span>
                                 <span class="s2">&quot; with </span><span class="si">{}</span><span class="s2"> dimensions.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indexing operation returned an invalid type </span><span class="si">{}</span><span class="s2">.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ret</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements self[index] = value.</span>

<span class="sd">        This operation is offloaded to NumPy. Hence, it supports all NumPy array</span>
<span class="sd">        indexing schemes: field access, basic slicing and advanced indexing.</span>
<span class="sd">        For details see `NumPy Array Indexing`_.</span>

<span class="sd">        .. _NumPy Array Indexing:</span>
<span class="sd">            https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements value in self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># All strings are unicode in Python 3, while we have to encode unicode</span>
        <span class="c1"># strings in Python2. If we can&#39;t, let python decide the best</span>
        <span class="c1"># characters to replace unicode characters with.</span>
        <span class="c1"># Below implementation was taken from</span>
        <span class="c1"># https://github.com/pytorch/pytorch/blob/master/torch/tensor.py</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
            <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_matrix_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="s1">&#39;encoding&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_matrix_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">or</span> <span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_matrix_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>

    <span class="c1"># Numpy array interface methods were adapted from PyTorch.</span>
    <span class="c1"># https://github.com/pytorch/pytorch/commit/c488a9e9bf9eddca6d55957304612b88f4638ca7</span>

    <span class="c1"># Numpy array interface, to support `numpy.asarray(vector) -&gt; ndarray`</span>
    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Wrap Numpy array in a vector or matrix when done, to support e.g.</span>
    <span class="c1"># `numpy.sin(vector) -&gt; vector` or `numpy.greater(vector, 0) -&gt; vector`</span>
    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;bad scalar </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
                <span class="c1"># Vector stores single precision floats.</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">SubVector</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
                <span class="c1"># Matrix stores single precision floats.</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">SubMatrix</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> dimensional array cannot be converted to a &#39;</span>
                               <span class="s1">&#39;Kaldi vector or matrix type&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>


<div class="viewcode-block" id="Matrix"><a class="viewcode-back" href="../../api/kaldi.matrix.html#kaldi.matrix.Matrix">[docs]</a><span class="k">class</span> <span class="nc">Matrix</span><span class="p">(</span><span class="n">_MatrixBase</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">Matrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Single precision matrix.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix():</span>
<span class="sd">            Creates an empty matrix.</span>

<span class="sd">        Matrix(num_rows: int, num_cols: int):</span>
<span class="sd">            Creates a new matrix of given size and fills it with zeros.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_rows (int): Number of rows of the new matrix.</span>
<span class="sd">            num_cols (int): Number of cols of the new matrix.</span>

<span class="sd">        Matrix(obj: matrix_like):</span>
<span class="sd">            Creates a new matrix with the elements in obj.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (matrix_like): A matrix, a 2-D numpy array, any object exposing</span>
<span class="sd">                a 2-D array interface, an object with an __array__ method</span>
<span class="sd">                returning a 2-D numpy array, or any (nested) sequence that can</span>
<span class="sd">                be interpreted as a matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;__init__() takes 1 to 3 positional arguments but &quot;</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> were given&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Matrix</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_cols</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;num_rows and num_cols should be integers&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_cols</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;num_rows and num_cols should both be &quot;</span>
                                     <span class="s2">&quot;positive or they should both be 0.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">,</span>
                                <span class="n">_packed_matrix</span><span class="o">.</span><span class="n">PackedMatrix</span><span class="p">,</span>
                                <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">,</span>
                                <span class="n">_packed_matrix</span><span class="o">.</span><span class="n">DoublePackedMatrix</span><span class="p">,</span>
                                <span class="n">_compressed_matrix</span><span class="o">.</span><span class="n">CompressedMatrix</span><span class="p">)):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;obj should be a 2-D matrix like object.&quot;</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">SubMatrix</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span>
                     <span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixResizeType</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes a row from the matrix.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;index=</span><span class="si">{}</span><span class="s2"> should be in the range [0,</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_row_</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="SubMatrix"><a class="viewcode-back" href="../../api/kaldi.matrix.html#kaldi.matrix.SubMatrix">[docs]</a><span class="k">class</span> <span class="nc">SubMatrix</span><span class="p">(</span><span class="n">_MatrixBase</span><span class="p">,</span> <span class="n">_matrix_ext</span><span class="o">.</span><span class="n">SubMatrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Single precision matrix view.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">row_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">num_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new matrix view from a matrix like object.</span>

<span class="sd">        If possible the new matrix view will share its data with the `obj`,</span>
<span class="sd">        i.e. no copy will be made. A copy will only be made if `obj.__array__`</span>
<span class="sd">        returns a copy, if `obj` is a sequence, or if a copy is needed to</span>
<span class="sd">        satisfy any of the other requirements (data type, order, etc.).</span>
<span class="sd">        Regardless of whether a copy is made or not, the new matrix view will</span>
<span class="sd">        not own the memory buffer backing it, i.e. it will not support matrix</span>
<span class="sd">        operations that reallocate memory.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (matrix_like): A matrix, a 2-D numpy array, any object exposing</span>
<span class="sd">                a 2-D array interface, an object with an __array__ method</span>
<span class="sd">                returning a 2-D numpy array, or any sequence that can be</span>
<span class="sd">                interpreted as a matrix.</span>
<span class="sd">            row_start (int): The start row index. Defaults to ``0``.</span>
<span class="sd">            num_rows (int): The number of rows. If ``None``, it is set to</span>
<span class="sd">                `self.num_rows - row_start`. Defaults to ``None``.</span>
<span class="sd">            col_start (int): The start column index. Defaults to ``0``.</span>
<span class="sd">            num_cols (int): The number of columns. If ``None``, it is set to</span>
<span class="sd">                `self.num_cols - col_start`. Defaults to ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;obj should be a 2-D matrix like object.&quot;</span><span class="p">)</span>
            <span class="n">obj_num_rows</span><span class="p">,</span> <span class="n">obj_num_cols</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj_num_rows</span><span class="p">,</span> <span class="n">obj_num_cols</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">num_cols</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row_start</span> <span class="o">&lt;=</span> <span class="n">obj_num_rows</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;row_start=</span><span class="si">{0}</span><span class="s2"> should be in the range [0,</span><span class="si">{1}</span><span class="s2">] &quot;</span>
                             <span class="s2">&quot;when obj.num_rows=</span><span class="si">{1}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">row_start</span><span class="p">,</span> <span class="n">obj_num_rows</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col_start</span> <span class="o">&lt;=</span> <span class="n">obj_num_cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;col_start=</span><span class="si">{0}</span><span class="s2"> should be in the range [0,</span><span class="si">{1}</span><span class="s2">] &quot;</span>
                             <span class="s2">&quot;when obj.num_cols=</span><span class="si">{1}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col_offset</span><span class="p">,</span> <span class="n">obj_num_cols</span><span class="p">))</span>
        <span class="n">max_rows</span><span class="p">,</span> <span class="n">max_cols</span> <span class="o">=</span> <span class="n">obj_num_rows</span> <span class="o">-</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">obj_num_cols</span> <span class="o">-</span> <span class="n">col_start</span>
        <span class="k">if</span> <span class="n">num_rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">max_rows</span>
        <span class="k">if</span> <span class="n">num_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_cols</span> <span class="o">=</span> <span class="n">max_cols</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">num_rows</span> <span class="o">&lt;=</span> <span class="n">max_rows</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;num_rows=</span><span class="si">{}</span><span class="s2"> should be in the range [0,</span><span class="si">{}</span><span class="s2">] &quot;</span>
                             <span class="s2">&quot;when row_start=</span><span class="si">{}</span><span class="s2"> and obj.num_rows=</span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">max_rows</span><span class="p">,</span>
                                     <span class="n">row_start</span><span class="p">,</span> <span class="n">obj_num_rows</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">num_cols</span> <span class="o">&lt;=</span> <span class="n">max_cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;num_cols=</span><span class="si">{}</span><span class="s2"> should be in the range [0,</span><span class="si">{}</span><span class="s2">] &quot;</span>
                             <span class="s2">&quot;when col_start=</span><span class="si">{}</span><span class="s2"> and obj.num_cols=</span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_cols</span><span class="p">,</span> <span class="n">max_cols</span><span class="p">,</span>
                                     <span class="n">col_start</span><span class="p">,</span> <span class="n">obj_num_cols</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_cols</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;num_rows and num_cols should both be &quot;</span>
                                 <span class="s2">&quot;positive or they should both be 0.&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SubMatrix</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span>
                                        <span class="n">col_start</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">)</span></div>


<span class="c1">################################################################################</span>
<span class="c1"># double precision vector/matrix types</span>
<span class="c1">################################################################################</span>


<span class="k">class</span> <span class="nc">_DoubleVectorBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the additional API for double precision vectors.</span>

<span class="sd">    No constructor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">copy_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from another vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            src (Vector or DoubleVector): The input vector.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">src</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vector of size </span><span class="si">{}</span><span class="s2"> cannot be copied into vector &quot;</span>
                             <span class="s2">&quot;of size </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_from_vec_</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_from_single_vec_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input vector type is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clones the vector.</span>

<span class="sd">        The clone allocates new memory for its contents and supports vector</span>
<span class="sd">        operations that reallocate memory, i.e. it is not a view.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DoubleVector: A copy of the vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the size of the vector as a single element tuple.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Single element tuple representing the size of the vector.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">approx_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if vectors are approximately equal.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (DoubleVector): The vector to compare against.</span>
<span class="sd">            tol (float): The tolerance for the equality check.</span>
<span class="sd">                Defaults to ``0.01``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if `self.dim == other.dim` and</span>
<span class="sd">            `||self-other|| &lt;= tol*||self||`. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_approx_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">approx_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the vector to a 1-D NumPy array.</span>

<span class="sd">        The NumPy array is a view into the vector, i.e. no data is copied.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A NumPy array sharing data with this vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_matrix_ext</span><span class="o">.</span><span class="n">double_vector_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector data as a memoryview.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the given range of elements as a new vector view.</span>

<span class="sd">        Args:</span>
<span class="sd">            start (int): The start index.</span>
<span class="sd">            length (int): The length.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DoubleSubVector: A vector view representing the given range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DoubleSubVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_vec_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds another vector.</span>

<span class="sd">        Performs the operation :math:`y = y + \\alpha\\ v`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier.</span>
<span class="sd">            v (Vector or DoubleVector): The input vector.</span>

<span class="sd">        Raises:</span>
<span class="sd">          RuntimeError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_vec_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_single_vec_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input vector type is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_vec2_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the squares of elements from another vector.</span>

<span class="sd">        Performs the operation :math:`y = y + \\alpha\\ v\\odot v`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier.</span>
<span class="sd">            v (Vector or DoubleVector): The input vector.</span>

<span class="sd">        Raises:</span>
<span class="sd">          RuntimeError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_vec2_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_single_vec2_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input vector type is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_mat_vec_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes a matrix-vector product.</span>

<span class="sd">        Performs the operation :math:`y = \\alpha\\ M\\ v + \\beta\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier for the matrix-vector product.</span>
<span class="sd">            M (DoubleMatrix or DoubleSpMatrix or DoubleTpMatrix): The input matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **M** or its transpose.</span>
<span class="sd">            v (DoubleVector): The input vector.</span>
<span class="sd">            beta (float): The scalar multiplier for the destination vector.</span>
<span class="sd">            sparse (bool): Whether to use the algorithm that is faster when</span>
<span class="sd">                **v** is sparse. Defaults to ``False``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix of size </span><span class="si">{}</span><span class="s2">x</span><span class="si">{}</span><span class="s2"> cannot be multiplied with &quot;</span>
                             <span class="s2">&quot;vector of size </span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vector of size </span><span class="si">{}</span><span class="s2"> cannot be added to vector of &quot;</span>
                             <span class="s2">&quot;size </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_mat_svec_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_mat_vec_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">DoubleSpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_sp_vec_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">DoubleTpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_tp_vec_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">mul_tp_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiplies the vector with a lower-triangular matrix.</span>

<span class="sd">        Performs the operation :math:`y = M\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (DoubleTpMatrix): The input lower-triangular matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **M** or its transpose.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix with size </span><span class="si">{}</span><span class="s2">x</span><span class="si">{}</span><span class="s2"> cannot be multiplied &quot;</span>
                             <span class="s2">&quot;with vector of size </span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_mul_tp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">solve_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves a linear system.</span>

<span class="sd">        The linear system is defined as :math:`M\\ x = b`, where :math:`b` and</span>
<span class="sd">        :math:`x` are the initial and final values of the vector, respectively.</span>

<span class="sd">        Warning:</span>
<span class="sd">            Does not test for :math:`M` being singular or near-singular.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (DoubleTpMatrix): The input lower-triangular matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **M** or its transpose.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of rows of the input matrix (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                             <span class="s2">&quot;should match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_solve_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_rows_from_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from a matrix row-by-row.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (Matrix or DoubleMatrix): The input matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">*</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of elements of the input matrix (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                             <span class="s2">&quot;should match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">*</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_rows_from_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_rows_from_single_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_cols_from_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from a matrix column-by-columm.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (DoubleMatrix): The input matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">*</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of elements of the input matrix (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                             <span class="s2">&quot;should match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">*</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_cols_from_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_row_from_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from a matrix row.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (Matrix or DoubleMatrix or SpMatrix or DoubleSpMatrix):</span>
<span class="sd">                The input matrix.</span>
<span class="sd">            row (int): The row index.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">            IndexError: If the row index is out-of-bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of columns of the input matrix (</span><span class="si">{}</span><span class="s2">)&quot;</span>
                             <span class="s2">&quot;should match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_row_from_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_row_from_single_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">DoubleSpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_row_from_sp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_row_from_single_sp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_col_from_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from a matrix column.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (Matrix or DoubleMatrix): The input matrix.</span>
<span class="sd">            col (int): The column index.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">            IndexError: If the column index is out-of-bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of rows of the input matrix (</span><span class="si">{}</span><span class="s2">)&quot;</span>
                             <span class="s2">&quot;should match the size of this vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">instance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_col_from_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_col_from_single_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_diag_from_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the digonal elements from a matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (Matrix or DoubleSpMatrix or DoubleTpMatrix): The input matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="nb">min</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The size of the matrix diagonal (</span><span class="si">{}</span><span class="s2">) should &quot;</span>
                             <span class="s2">&quot;match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_diag_from_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">DoubleSpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_diag_from_sp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">DoubleTpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_diag_from_tp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_from_packed_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from a packed matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (SpMatrix or TpMatrix or DoubleSpMatrix or DoubleTpMatrix):</span>
<span class="sd">                The input packed matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `self.dim !=  M.num_rows * (M.num_rows + 1) / 2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numel</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">numel</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of elements of the input packed matrix&quot;</span>
                             <span class="s2">&quot; (</span><span class="si">{}</span><span class="s2">) should match the size of the vector (</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_packed_matrix</span><span class="o">.</span><span class="n">DoublePackedMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_from_packed_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_packed_matrix</span><span class="o">.</span><span class="n">PackedMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_copy_from_single_packed_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_row_sum_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the sum of matrix rows.</span>

<span class="sd">        Performs the operation :math:`y = \\alpha\\ \\sum_i M[i] + \\beta\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier for the row sum.</span>
<span class="sd">            M (DoubleMatrix): The input matrix.</span>
<span class="sd">            beta (float): The scalar multiplier for the destination vector.</span>
<span class="sd">                Defaults to ``1.0``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `self.dim != M.num_cols`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot add sum of rows with size </span><span class="si">{}</span><span class="s2"> to &quot;</span>
                             <span class="s2">&quot;vector of size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_row_sum_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_col_sum_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the sum of matrix columns.</span>

<span class="sd">        Performs the operation</span>
<span class="sd">        :math:`y = \\alpha\\ \\sum_i M[:,i] + \\beta\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier for the column sum.</span>
<span class="sd">            M (DoubleMatrix): The input matrix.</span>
<span class="sd">            beta (float): The scalar multiplier for the destination vector.</span>
<span class="sd">                Defaults to ``1.0``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `self.dim != M.num_rows`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot add sum of columns with size </span><span class="si">{}</span><span class="s2"> to &quot;</span>
                             <span class="s2">&quot;vector of size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_col_sum_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_diag_mat2_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span>
                       <span class="n">trans</span><span class="o">=</span><span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">,</span>
                       <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the diagonal of a matrix multiplied with its transpose.</span>

<span class="sd">        Performs the operation :math:`y = \\alpha\\ diag(M M^T) + \\beta\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier for the diagonal.</span>
<span class="sd">            M (DoubleMatrix): The input matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **M** or its transpose.</span>
<span class="sd">                Defaults to ``MatrixTransposeType.NO_TRANS``.</span>
<span class="sd">            beta (float): The scalar multiplier for the destination vector.</span>
<span class="sd">                Defaults to ``1.0``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot add diagonal with size </span><span class="si">{}</span><span class="s2"> to &quot;</span>
                             <span class="s2">&quot;vector of size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_diag_mat2_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_diag_mat_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">transM</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">transN</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the diagonal of a matrix-matrix product.</span>

<span class="sd">        Performs the operation :math:`y = \\alpha\\ diag(M N) + \\beta\\ y`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier for the diagonal.</span>
<span class="sd">            M (DoubleMatrix): The first input matrix.</span>
<span class="sd">            transM (MatrixTransposeType): Whether to use **M** or its transpose.</span>
<span class="sd">            N (DoubleMatrix): The second input matrix.</span>
<span class="sd">            transN (MatrixTransposeType): Whether to use **N** or its transpose.</span>
<span class="sd">            beta (float): The scalar multiplier for the destination vector.</span>
<span class="sd">                Defaults to ``1.0``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">transM</span> <span class="o">==</span> <span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transN</span> <span class="o">==</span> <span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">p</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply M (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">) with &quot;</span>
                                     <span class="s2">&quot;N (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">q</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply M (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">) with &quot;</span>
                                     <span class="s2">&quot;N^T (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">transN</span> <span class="o">==</span> <span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">p</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply M (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">) with &quot;</span>
                                     <span class="s2">&quot;N (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">q</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply M (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">) with &quot;</span>
                                     <span class="s2">&quot;N (</span><span class="si">{}</span><span class="s2"> by </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_add_diag_mat_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">transM</span><span class="p">,</span>
                                                   <span class="n">N</span><span class="p">,</span> <span class="n">transN</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mul_elements_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiplies the elements with the elements of another vector.</span>

<span class="sd">        Performs the operation `y[i] *= v[i]`.</span>

<span class="sd">        Args:</span>
<span class="sd">            v (Vector or DoubleVector): The input vector.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mul_elements_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_mul_single_elements_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input vector type is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">div_elements_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Divides the elements with the elements of another vector.</span>

<span class="sd">        Performs the operation `y[i] /= v[i]`.</span>

<span class="sd">        Args:</span>
<span class="sd">            v (Vector or DoubleVector): The input vector.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_div_elements_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">):</span>
            <span class="n">_kaldi_vector_ext</span><span class="o">.</span><span class="n">_div_single_elements_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input vector type is not supported.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># All strings are unicode in Python 3, while we have to encode unicode</span>
        <span class="c1"># strings in Python2. If we can&#39;t, let python decide the best</span>
        <span class="c1"># characters to replace unicode characters with.</span>
        <span class="c1"># Below implementation was taken from</span>
        <span class="c1"># https://github.com/pytorch/pytorch/blob/master/torch/tensor.py</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
            <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_vector_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="s1">&#39;encoding&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_vector_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">or</span> <span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_vector_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements self[index].</span>

<span class="sd">        This operation is offloaded to numpy. Hence, it supports all numpy array</span>
<span class="sd">        indexing schemes: field access, basic slicing and advanced indexing.</span>
<span class="sd">        For details see `NumPy Array Indexing`_.</span>

<span class="sd">        Slicing shares data with the source vector when possible (see Caveats).</span>

<span class="sd">        Returns:</span>
<span class="sd">            - a float if the result of numpy indexing is a scalar</span>
<span class="sd">            - a DoubleSubVector if the result of numpy indexing is 1 dimensional</span>
<span class="sd">            - a DoubleSubMatrix if the result of numpy indexing is 2 dimensional</span>

<span class="sd">        Caveats:</span>
<span class="sd">            - Kaldi vector and matrix types do not support non-contiguous memory</span>
<span class="sd">              layouts for the last dimension, i.e. the stride for the last</span>
<span class="sd">              dimension should be the size of a float. If the result of numpy</span>
<span class="sd">              slicing operation has an unsupported stride value for the last</span>
<span class="sd">              dimension, the return value will not share any data with the</span>
<span class="sd">              source vector, i.e. a copy will be made. Consider the following:</span>
<span class="sd">                &gt;&gt;&gt; v = DoubleVector(5)</span>
<span class="sd">                &gt;&gt;&gt; s = v[0:4:2]     # s does not share data with v</span>
<span class="sd">                &gt;&gt;&gt; s[:] = v[1:4:2]  # changing s will not change v</span>
<span class="sd">              Since the slicing operation requires a copy of the data to be</span>
<span class="sd">              made, the source vector v will not be updated. On the other hand,</span>
<span class="sd">              the following assignment operation will work as expected since</span>
<span class="sd">              __setitem__ method does not create a new vector for representing</span>
<span class="sd">              the left hand side:</span>
<span class="sd">                &gt;&gt;&gt; v[0:4:2] = v[1:4:2]</span>

<span class="sd">        .. _NumPy Array Indexing:</span>
<span class="sd">            https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">DoubleSubVector</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">DoubleSubMatrix</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indexing operation returned a numpy array &quot;</span>
                                 <span class="s2">&quot; with </span><span class="si">{}</span><span class="s2"> dimensions.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indexing operation returned an invalid type </span><span class="si">{}</span><span class="s2">.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ret</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements self[index] = value.</span>

<span class="sd">        This operation is offloaded to NumPy. Hence, it supports all NumPy array</span>
<span class="sd">        indexing schemes: field access, basic slicing and advanced indexing.</span>
<span class="sd">        For details see `NumPy Array Indexing`_.</span>

<span class="sd">        .. _NumPy Array Indexing:</span>
<span class="sd">            https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># Numpy array interface methods were adapted from PyTorch.</span>
    <span class="c1"># https://github.com/pytorch/pytorch/commit/c488a9e9bf9eddca6d55957304612b88f4638ca7</span>

    <span class="c1"># Numpy array interface, to support `numpy.asarray(vector) -&gt; ndarray`</span>
    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Wrap Numpy array in a vector or matrix when done, to support e.g.</span>
    <span class="c1"># `numpy.sin(vector) -&gt; vector` or `numpy.greater(vector, 0) -&gt; vector`</span>
    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;bad scalar </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
                <span class="c1"># DoubleVector stores double precision floats.</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">DoubleSubVector</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
                <span class="c1"># DoubleMatrix stores double precision floats.</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">DoubleSubMatrix</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> dimensional array cannot be converted to a &#39;</span>
                               <span class="s1">&#39;Kaldi vector or matrix type&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>


<div class="viewcode-block" id="DoubleVector"><a class="viewcode-back" href="../../api/kaldi.matrix.html#kaldi.matrix.DoubleVector">[docs]</a><span class="k">class</span> <span class="nc">DoubleVector</span><span class="p">(</span><span class="n">_DoubleVectorBase</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Double precision vector.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DoubleVector():</span>
<span class="sd">            Creates an empty vector.</span>

<span class="sd">        DoubleVector(size: int):</span>
<span class="sd">            Creates a new vector of given size and fills it with zeros.</span>

<span class="sd">        Args:</span>
<span class="sd">            size (int): Size of the new vector.</span>

<span class="sd">        DoubleVector(obj: vector_like):</span>
<span class="sd">            Creates a new vector with the elements in obj.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (vector_like): A vector, a 1-D numpy array, any object exposing</span>
<span class="sd">                a 1-D array interface, an object with an __array__ method</span>
<span class="sd">                returning a 1-D numpy array, or any sequence that can be</span>
<span class="sd">                interpreted as a vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;__init__() takes 1 to 2 positional arguments but &quot;</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> were given&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DoubleVector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size should non-negative&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">,</span>
                                <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">VectorBase</span><span class="p">)):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;obj should be a 1-D vector like object.&quot;</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">DoubleSubVector</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixResizeType</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes an element from the vector.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;index=</span><span class="si">{}</span><span class="s2"> should be in the range [0,</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_element_</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="DoubleSubVector"><a class="viewcode-back" href="../../api/kaldi.matrix.html#kaldi.matrix.DoubleSubVector">[docs]</a><span class="k">class</span> <span class="nc">DoubleSubVector</span><span class="p">(</span><span class="n">_DoubleVectorBase</span><span class="p">,</span> <span class="n">_matrix_ext</span><span class="o">.</span><span class="n">DoubleSubVector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Double precision vector view.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new vector view from a vector like object.</span>

<span class="sd">        If possible the new vector view will share its data with the `obj`,</span>
<span class="sd">        i.e. no copy will be made. A copy will only be made if `obj.__array__`</span>
<span class="sd">        returns a copy, if `obj` is a sequence, or if a copy is needed to</span>
<span class="sd">        satisfy any of the other requirements (data type, order, etc.).</span>
<span class="sd">        Regardless of whether a copy is made or not, the new vector view will</span>
<span class="sd">        not own the memory buffer backing it, i.e. it will not support vector</span>
<span class="sd">        operations that reallocate memory.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (vector_like): A vector, a 1-D numpy array, any object exposing</span>
<span class="sd">                a 1-D array interface, an object whose __array__ method returns</span>
<span class="sd">                a 1-D numpy array, or any sequence that can be interpreted as a</span>
<span class="sd">                vector.</span>
<span class="sd">            start (int): The index of the view start. Defaults to 0.</span>
<span class="sd">            length (int): The length of the view. If None, it is set to</span>
<span class="sd">                len(obj) - start. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVectorBase</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;obj should be a 1-D vector like object.&quot;</span><span class="p">)</span>
        <span class="n">obj_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">obj_len</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;start=</span><span class="si">{0}</span><span class="s2"> should be in the range [0,</span><span class="si">{1}</span><span class="s2">] &quot;</span>
                             <span class="s2">&quot;when len(obj)=</span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">obj_len</span><span class="p">))</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="n">obj_len</span> <span class="o">-</span> <span class="n">start</span>
        <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">max_len</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">max_len</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;length=</span><span class="si">{}</span><span class="s2"> should be in the range [0,</span><span class="si">{}</span><span class="s2">] when &quot;</span>
                             <span class="s2">&quot;start=</span><span class="si">{}</span><span class="s2"> and len(obj)=</span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">max_len</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">obj_len</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DoubleSubVector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_DoubleMatrixBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class defining the additional API for single precision matrices.</span>

<span class="sd">    No constructor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">copy_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the elements from another matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">            src (Matrix or SpMatrix or TpMatrix or DoubleMatrix or DoubleSpMatrix or DoubleTpMatrix or CompressedMatrix):</span>
<span class="sd">                The input matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **src** or its transpose.</span>
<span class="sd">                Defaults to ``MatrixTransposeType.NO_TRANS``. Not active if</span>
<span class="sd">                input is a compressed matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">src</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot copy matrix with dimensions </span><span class="si">{s[0]}</span><span class="s2">x</span><span class="si">{s[1]}</span><span class="s2"> &quot;</span>
                             <span class="s2">&quot;into matrix with dimensions </span><span class="si">{d[0]}</span><span class="s2">x</span><span class="si">{d[1]}</span><span class="s2">&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_copy_from_mat_</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">DoubleSpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_sp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">DoubleTpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_tp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_single_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_single_sp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">TpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_single_tp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_compressed_matrix</span><span class="o">.</span><span class="n">CompressedMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_from_cmat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clones the matrix.</span>

<span class="sd">        The clone allocates new memory for its contents and supports matrix</span>
<span class="sd">        operations that reallocate memory, i.e. it is not a view.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DoubleMatrix: A copy of the matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DoubleMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the size of the matrix.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple (num_rows, num_cols) of integers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Two element tuple representing the size of the matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">approx_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if matrices are approximately equal.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (DoubleMatrix): The matrix to compare against.</span>
<span class="sd">            tol (float): The tolerance for the equality check.</span>
<span class="sd">                Defaults to ``0.01``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if `self.size() == other.size()` and</span>
<span class="sd">            `||self-other|| &lt;= tol*||self||`. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">num_rows</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">num_cols</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_approx_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">approx_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the matrix to a 2-D NumPy array.</span>

<span class="sd">        The NumPy array is a view into the matrix, i.e. no data is copied.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: A NumPy array sharing data with this matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_matrix_ext</span><span class="o">.</span><span class="n">double_matrix_to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Matrix data as a memoryview.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">row_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns row data as a memoryview.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the given row as a new vector view.</span>

<span class="sd">        Args:</span>
<span class="sd">            index (int): The row index.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DoubleSubVector: A vector view representing the given row.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">col_start</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the given range of elements as a new matrix view.</span>

<span class="sd">        Args:</span>
<span class="sd">            row_start (int): The start row index.</span>
<span class="sd">            num_rows (int): The number of rows.</span>
<span class="sd">            col_start (int): The start column index.</span>
<span class="sd">            num_cols (int): The number of columns.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DoubleSubMatrix: A matrix view representing the given range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DoubleSubMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">col_start</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">row_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the given range of rows as a new matrix view.</span>

<span class="sd">        Args:</span>
<span class="sd">            row_start (int): The start row index.</span>
<span class="sd">            num_rows (int): The number of rows.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DoubleSubMatrix: A matrix view representing the given row range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DoubleSubMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">col_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_start</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the given range of columns as a new matrix view.</span>

<span class="sd">        Args:</span>
<span class="sd">            col_start (int): The start column index.</span>
<span class="sd">            num_cols (int): The number of columns.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DoubleSubMatrix: A matrix view representing the given column range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DoubleSubMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">col_start</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eig</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes eigendecomposition.</span>

<span class="sd">        Factorizes a square matrix into :math:`P\\ D\\ P^{-1}`.</span>

<span class="sd">        The relationship of :math:`D` to the eigenvalues is slightly</span>
<span class="sd">        complicated, due to the need for :math:`P` to be real. In the symmetric</span>
<span class="sd">        case, :math:`D` is diagonal and real, but in the non-symmetric case</span>
<span class="sd">        there may be complex-conjugate pairs of eigenvalues. In this case, for</span>
<span class="sd">        the equation :math:`y = P\\ D\\ P^{-1}` to hold, :math:`D` must actually</span>
<span class="sd">        be block diagonal, with 2x2 blocks corresponding to any such pairs. If a</span>
<span class="sd">        pair is :math:`\\lambda +- i\\mu`, :math:`D` will have a corresponding</span>
<span class="sd">        2x2 block :math:`[\\lambda, \\mu; -\\mu, \\lambda]`. Note that if the</span>
<span class="sd">        matrix is not invertible, :math:`P` may not be invertible so in this</span>
<span class="sd">        case instead of the equation :math:`y = P\\ D\\ P^{-1}` holding, we have</span>
<span class="sd">        :math:`y\\ P = P\\ D`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            3-element tuple containing</span>

<span class="sd">            - **P** (:class:`DoubleMatrix`): The eigenvector matrix, where ith</span>
<span class="sd">              column corresponds to the ith eigenvector.</span>
<span class="sd">            - **r** (:class:`DoubleVector`): The vector with real components of</span>
<span class="sd">              the eigenvalues.</span>
<span class="sd">            - **i** (:class:`DoubleVector`): The vector with imaginary</span>
<span class="sd">              components of the eigenvalues.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the matrix is not square.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;eig method cannot be called on a non-square &quot;</span>
                             <span class="s2">&quot;matrix.&quot;</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">DoubleMatrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eig</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">svd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">destructive</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes singular-value decomposition.</span>

<span class="sd">        Factorizes a matrix into :math:`U\\ diag(s)\\ V^T`.</span>

<span class="sd">        For non-square matrices, requires `self.num_rows &gt;= self.num_cols`.</span>

<span class="sd">        Args:</span>
<span class="sd">            destructive (bool): Whether to use the destructive operation which</span>
<span class="sd">                avoids a copy but mutates self. Defaults to ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            3-element tuple containing</span>

<span class="sd">            - **s** (:class:`DoubleVector`): The vector of singular values.</span>
<span class="sd">            - **U** (:class:`DoubleMatrix`): The left orthonormal matrix.</span>
<span class="sd">            - **Vt** (:class:`DoubleMatrix`): The right orthonormal matrix.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `self.num_rows &lt; self.num_cols`.</span>

<span class="sd">        Note:</span>
<span class="sd">          **Vt** in the output is already transposed.</span>
<span class="sd">          The singular values in **s** are not sorted.</span>

<span class="sd">        See Also:</span>
<span class="sd">          :meth:`singular_values`</span>
<span class="sd">          :meth:`sort_svd`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;svd for non-square matrices requires &quot;</span>
                             <span class="s2">&quot;self.num_rows &gt;= self.num_cols.&quot;</span><span class="p">)</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">DoubleMatrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">DoubleMatrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">destructive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_destructive_svd_</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Vt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_svd</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Vt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Vt</span>

    <span class="k">def</span> <span class="nf">singular_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes singular values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DoubleVector: The vector of singular values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">DoubleVector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_singular_values</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">add_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span>
                 <span class="n">trans</span><span class="o">=</span><span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds another matrix to this one.</span>

<span class="sd">        Performs the operation :math:`S = \\alpha\\ M + S`.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): The scalar multiplier.</span>
<span class="sd">            M (DoubleMatrix or SpMatrix or DoubleSpMatrix): The input matrix.</span>
<span class="sd">            trans (MatrixTransposeType): Whether to use **M** or its transpose.</span>
<span class="sd">                Defaults to ``MatrixTransposeType.NO_TRANS``.</span>

<span class="sd">        Raises:</span>
<span class="sd">          RuntimeError: In case of size mismatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_mat_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">DoubleSpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">add_sp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">SpMatrix</span><span class="p">):</span>
            <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">add_single_sp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input matrix type is not supported.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_mat_mat_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span>
                     <span class="n">transA</span><span class="o">=</span><span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">,</span>
                     <span class="n">transB</span><span class="o">=</span><span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixTransposeType</span><span class="o">.</span><span class="n">NO_TRANS</span><span class="p">,</span>
                     <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sparseA</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparseB</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the product of given matrices.</span>

<span class="sd">        Performs the operation :math:`M = \\alpha\\ A\\ B + \\beta\\ M`.</span>

<span class="sd">        Args:</span>
<span class="sd">            A (DoubleMatrix or DoubleTpMatrix or DoubleSpMatrix):</span>
<span class="sd">                The first input matrix.</span>
<span class="sd">            B (DoubleMatrix or DoubleTpMatrix or DoubleSpMatrix):</span>
<span class="sd">                The second input matrix.</span>
<span class="sd">            transA (MatrixTransposeType): Whether to use **A** or its transpose.</span>
<span class="sd">                Defaults to ``MatrixTransposeType.NO_TRANS``.</span>
<span class="sd">            transB (MatrixTransposeType): Whether to use **B** or its transpose.</span>
<span class="sd">                Defaults to ``MatrixTransposeType.NO_TRANS``.</span>
<span class="sd">            alpha (float): The scalar multiplier for the product.</span>
<span class="sd">                Defaults to ``1.0``.</span>
<span class="sd">            beta (float): The scalar multiplier for the destination vector.</span>
<span class="sd">                Defaults to ``1.0``.</span>
<span class="sd">            sparseA (bool): Whether to use the algorithm that is faster when</span>
<span class="sd">                **A** is sparse. Defaults to ``False``.</span>
<span class="sd">            sparseA (bool): Whether to use the algorithm that is faster when</span>
<span class="sd">                **B** is sparse. Defaults to ``False``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: In case of size mismatch.</span>
<span class="sd">            TypeError: If matrices of given types can not be multiplied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sparseA</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_smat_mat_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">sparseB</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_mat_smat_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_mat_mat_</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">DoubleSpMatrix</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_mat_sp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span>
                                                     <span class="n">B</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">DoubleTpMatrix</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_mat_tp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span>
                                                     <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply matrix A with matrix B of &quot;</span>
                                <span class="s2">&quot;type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">DoubleSpMatrix</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_sp_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span>
                                                     <span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_sp_matrix</span><span class="o">.</span><span class="n">DoubleSpMatrix</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_sp_sp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span>
                                                    <span class="n">beta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply symmetric matrix A with &quot;</span>
                                <span class="s2">&quot;matrix B of type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">DoubleSpMatrix</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_tp_mat_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span>
                                                     <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">_tp_matrix</span><span class="o">.</span><span class="n">DoubleTpMatrix</span><span class="p">):</span>
                <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_tp_tp_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span>
                                                    <span class="n">B</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot multiply triangular matrix A with &quot;</span>
                                <span class="s2">&quot;matrix B of type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">invert_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverts the matrix.</span>

<span class="sd">        Returns:</span>
<span class="sd">            2-element tuple containing</span>

<span class="sd">            - **log_det** (:class:`float`): The log determinant.</span>
<span class="sd">            - **det_sign** (:class:`float`): The sign of the determinant, 1 or -1.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If matrix is not square.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_invert_double</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy_cols_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies columns from another matrix.</span>

<span class="sd">        Copies column `r` from column `indices[r]` of `src`. As a special case,</span>
<span class="sd">        if `indexes[i] == -1`, sets column `i` to zero. All elements of indices</span>
<span class="sd">        must be in `[-1, src.num_cols-1]`, and `src.num_rows` must equal</span>
<span class="sd">        `self.num_rows`.</span>

<span class="sd">        Args:</span>
<span class="sd">            src (DoubleMatrix): The input matrix.</span>
<span class="sd">            indices (List[int]): The list of column indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_cols_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy_rows_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies rows from another matrix.</span>

<span class="sd">        Copies row `r` from row `indices[r]` of `src`. As a special case, if</span>
<span class="sd">        `indexes[i] == -1`, sets row `i` to zero. All elements of indices must</span>
<span class="sd">        be in `[-1, src.num_rows-1]`, and `src.num_cols` must equal</span>
<span class="sd">        `self.num_cols`.</span>

<span class="sd">        Args:</span>
<span class="sd">            src (DoubleMatrix): The input matrix.</span>
<span class="sd">            indices (List[int]): The list of row indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_copy_rows_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_cols_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds columns from another matrix.</span>

<span class="sd">        Adds column `indices[r]` of `src` to column `r`. As a special case, if</span>
<span class="sd">        `indexes[i] == -1`, skips column `i`. All elements of indices must be in</span>
<span class="sd">        `[-1, src.num_cols-1]`, and `src.num_rows` must equal `self.num_rows`.</span>

<span class="sd">        Args:</span>
<span class="sd">            src (DoubleMatrix): The input matrix.</span>
<span class="sd">            indices (List[int]): The list of column indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_cols_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_rows_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds rows from another matrix.</span>

<span class="sd">        Scales row `indices[r]` of `src` with `alpha` and adds it to row `r`. As</span>
<span class="sd">        a special case, if `indexes[i] == -1`, skips row `i`. All elements of</span>
<span class="sd">        indices must be in `[-1, src.num_rows-1]`, and `src.num_cols` must equal</span>
<span class="sd">        `self.num_cols`.</span>

<span class="sd">        Args:</span>
<span class="sd">            src (DoubleMatrix): The input matrix.</span>
<span class="sd">            indices (List[int]): The list of row indices.</span>
<span class="sd">            alpha (float): The scalar multiplier. Defaults to `1.0`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_kaldi_matrix_ext</span><span class="o">.</span><span class="n">_add_rows_double</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements self[index].</span>

<span class="sd">        This operation is offloaded to NumPy. Hence, it supports all NumPy array</span>
<span class="sd">        indexing schemes: field access, basic slicing and advanced indexing.</span>
<span class="sd">        For details see `NumPy Array Indexing`_.</span>

<span class="sd">        Slicing shares data with the source matrix when possible (see Caveats).</span>

<span class="sd">        Returns:</span>
<span class="sd">            - a float if the result of numpy indexing is a scalar</span>
<span class="sd">            - a DoubleSubVector if the result of numpy indexing is 1 dimensional</span>
<span class="sd">            - a DoubleSubMatrix if the result of numpy indexing is 2 dimensional</span>

<span class="sd">        Caveats:</span>
<span class="sd">            - Kaldi vector and matrix types do not support non-contiguous memory</span>
<span class="sd">              layouts for the last dimension, i.e. the stride for the last</span>
<span class="sd">              dimension should be the size of a float. If the result of numpy</span>
<span class="sd">              slicing operation has an unsupported stride value for the last</span>
<span class="sd">              dimension, the return value will not share any data with the</span>
<span class="sd">              source matrix, i.e. a copy will be made. Consider the following:</span>
<span class="sd">                &gt;&gt;&gt; m = DoubleMatrix(3, 5)</span>
<span class="sd">                &gt;&gt;&gt; s = m[:,0:4:2]     # s does not share data with m</span>
<span class="sd">                &gt;&gt;&gt; s[:] = m[:,1:4:2]  # changing s will not change m</span>
<span class="sd">              Since the slicing operation requires a copy of the data to be</span>
<span class="sd">              made, the source matrix m will not be updated. On the other hand,</span>
<span class="sd">              the following assignment operation will work as expected since</span>
<span class="sd">              __setitem__ method does not create a new scalar/vector/matrix for</span>
<span class="sd">              representing the left hand side:</span>
<span class="sd">                &gt;&gt;&gt; m[:,0:4:2] = m[:,1:4:2]</span>

<span class="sd">        .. _NumPy Array Indexing:</span>
<span class="sd">            https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">DoubleSubMatrix</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">DoubleSubVector</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indexing operation returned a numpy array &quot;</span>
                                 <span class="s2">&quot; with </span><span class="si">{}</span><span class="s2"> dimensions.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;indexing operation returned an invalid type </span><span class="si">{}</span><span class="s2">.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ret</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements self[index] = value.</span>

<span class="sd">        This operation is offloaded to NumPy. Hence, it supports all NumPy array</span>
<span class="sd">        indexing schemes: field access, basic slicing and advanced indexing.</span>
<span class="sd">        For details see `NumPy Array Indexing`_.</span>

<span class="sd">        .. _NumPy Array Indexing:</span>
<span class="sd">            https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements value in self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># All strings are unicode in Python 3, while we have to encode unicode</span>
        <span class="c1"># strings in Python2. If we can&#39;t, let python decide the best</span>
        <span class="c1"># characters to replace unicode characters with.</span>
        <span class="c1"># Below implementation was taken from</span>
        <span class="c1"># https://github.com/pytorch/pytorch/blob/master/torch/tensor.py</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
            <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_matrix_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="s1">&#39;encoding&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_matrix_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">or</span> <span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_str</span><span class="o">.</span><span class="n">_matrix_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>

    <span class="c1"># Numpy array interface methods were adapted from PyTorch.</span>
    <span class="c1"># https://github.com/pytorch/pytorch/commit/c488a9e9bf9eddca6d55957304612b88f4638ca7</span>

    <span class="c1"># Numpy array interface, to support `numpy.asarray(vector) -&gt; ndarray`</span>
    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Wrap Numpy array in a vector or matrix when done, to support e.g.</span>
    <span class="c1"># `numpy.sin(vector) -&gt; vector` or `numpy.greater(vector, 0) -&gt; vector`</span>
    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;bad scalar </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
                <span class="c1"># DoubleVector stores single precision floats.</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">DoubleSubVector</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
                <span class="c1"># DoubleMatrix stores single precision floats.</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">DoubleSubMatrix</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> dimensional array cannot be converted to a &#39;</span>
                               <span class="s1">&#39;Kaldi vector or matrix type&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>


<div class="viewcode-block" id="DoubleMatrix"><a class="viewcode-back" href="../../api/kaldi.matrix.html#kaldi.matrix.DoubleMatrix">[docs]</a><span class="k">class</span> <span class="nc">DoubleMatrix</span><span class="p">(</span><span class="n">_DoubleMatrixBase</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Double precision matrix.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DoubleMatrix():</span>
<span class="sd">            Creates an empty matrix.</span>

<span class="sd">        DoubleMatrix(num_rows: int, num_cols: int):</span>
<span class="sd">            Creates a new matrix of given size and fills it with zeros.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_rows (int): Number of rows of the new matrix.</span>
<span class="sd">            num_cols (int): Number of cols of the new matrix.</span>

<span class="sd">        DoubleMatrix(obj: matrix_like):</span>
<span class="sd">            Creates a new matrix with the elements in obj.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (matrix_like): A matrix, a 2-D numpy array, any object exposing</span>
<span class="sd">                a 2-D array interface, an object with an __array__ method</span>
<span class="sd">                returning a 2-D numpy array, or any (nested) sequence that can</span>
<span class="sd">                be interpreted as a matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;__init__() takes 1 to 3 positional arguments but &quot;</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> were given&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DoubleMatrix</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_cols</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;num_rows and num_cols should be integers&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_cols</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;num_rows and num_cols should both be &quot;</span>
                                     <span class="s2">&quot;positive or they should both be 0.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">MatrixBase</span><span class="p">,</span>
                                <span class="n">_packed_matrix</span><span class="o">.</span><span class="n">PackedMatrix</span><span class="p">,</span>
                                <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">,</span>
                                <span class="n">_packed_matrix</span><span class="o">.</span><span class="n">DoublePackedMatrix</span><span class="p">,</span>
                                <span class="n">_compressed_matrix</span><span class="o">.</span><span class="n">CompressedMatrix</span><span class="p">)):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;obj should be a 2-D matrix like object.&quot;</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">DoubleSubMatrix</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span>
                     <span class="n">_matrix_common</span><span class="o">.</span><span class="n">MatrixResizeType</span><span class="o">.</span><span class="n">UNDEFINED</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes a row from the matrix.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;index=</span><span class="si">{}</span><span class="s2"> should be in the range [0,</span><span class="si">{}</span><span class="s2">).&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_row_</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="DoubleSubMatrix"><a class="viewcode-back" href="../../api/kaldi.matrix.html#kaldi.matrix.DoubleSubMatrix">[docs]</a><span class="k">class</span> <span class="nc">DoubleSubMatrix</span><span class="p">(</span><span class="n">_DoubleMatrixBase</span><span class="p">,</span> <span class="n">_matrix_ext</span><span class="o">.</span><span class="n">DoubleSubMatrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Double precision matrix view.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">row_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">num_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new matrix view from a matrix like object.</span>

<span class="sd">        If possible the new matrix view will share its data with the `obj`,</span>
<span class="sd">        i.e. no copy will be made. A copy will only be made if `obj.__array__`</span>
<span class="sd">        returns a copy, if `obj` is a sequence, or if a copy is needed to</span>
<span class="sd">        satisfy any of the other requirements (data type, order, etc.).</span>
<span class="sd">        Regardless of whether a copy is made or not, the new matrix view will</span>
<span class="sd">        not own the memory buffer backing it, i.e. it will not support matrix</span>
<span class="sd">        operations that reallocate memory.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj (matrix_like): A matrix, a 2-D numpy array, any object exposing</span>
<span class="sd">                a 2-D array interface, an object with an __array__ method</span>
<span class="sd">                returning a 2-D numpy array, or any sequence that can be</span>
<span class="sd">                interpreted as a matrix.</span>
<span class="sd">            row_start (int): The start row index. Defaults to ``0``.</span>
<span class="sd">            num_rows (int): The number of rows. If ``None``, it is set to</span>
<span class="sd">                `self.num_rows - row_start`. Defaults to ``None``.</span>
<span class="sd">            col_start (int): The start column index. Defaults to ``0``.</span>
<span class="sd">            num_cols (int): The number of columns. If ``None``, it is set to</span>
<span class="sd">                `self.num_cols - col_start`. Defaults to ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrixBase</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;obj should be a 2-D matrix like object.&quot;</span><span class="p">)</span>
            <span class="n">obj_num_rows</span><span class="p">,</span> <span class="n">obj_num_cols</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj_num_rows</span><span class="p">,</span> <span class="n">obj_num_cols</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">num_cols</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row_start</span> <span class="o">&lt;=</span> <span class="n">obj_num_rows</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;row_start=</span><span class="si">{0}</span><span class="s2"> should be in the range [0,</span><span class="si">{1}</span><span class="s2">] &quot;</span>
                             <span class="s2">&quot;when obj.num_rows=</span><span class="si">{1}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">row_start</span><span class="p">,</span> <span class="n">obj_num_rows</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col_start</span> <span class="o">&lt;=</span> <span class="n">obj_num_cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;col_start=</span><span class="si">{0}</span><span class="s2"> should be in the range [0,</span><span class="si">{1}</span><span class="s2">] &quot;</span>
                             <span class="s2">&quot;when obj.num_cols=</span><span class="si">{1}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col_offset</span><span class="p">,</span> <span class="n">obj_num_cols</span><span class="p">))</span>
        <span class="n">max_rows</span><span class="p">,</span> <span class="n">max_cols</span> <span class="o">=</span> <span class="n">obj_num_rows</span> <span class="o">-</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">obj_num_cols</span> <span class="o">-</span> <span class="n">col_start</span>
        <span class="k">if</span> <span class="n">num_rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="n">max_rows</span>
        <span class="k">if</span> <span class="n">num_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_cols</span> <span class="o">=</span> <span class="n">max_cols</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">num_rows</span> <span class="o">&lt;=</span> <span class="n">max_rows</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;num_rows=</span><span class="si">{}</span><span class="s2"> should be in the range [0,</span><span class="si">{}</span><span class="s2">] &quot;</span>
                             <span class="s2">&quot;when row_start=</span><span class="si">{}</span><span class="s2"> and obj.num_rows=</span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">max_rows</span><span class="p">,</span>
                                     <span class="n">row_start</span><span class="p">,</span> <span class="n">obj_num_rows</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">num_cols</span> <span class="o">&lt;=</span> <span class="n">max_cols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;num_cols=</span><span class="si">{}</span><span class="s2"> should be in the range [0,</span><span class="si">{}</span><span class="s2">] &quot;</span>
                             <span class="s2">&quot;when col_start=</span><span class="si">{}</span><span class="s2"> and obj.num_cols=</span><span class="si">{}</span><span class="s2">.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_cols</span><span class="p">,</span> <span class="n">max_cols</span><span class="p">,</span>
                                     <span class="n">col_start</span><span class="p">,</span> <span class="n">obj_num_cols</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_cols</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;num_rows and num_cols should both be &quot;</span>
                                 <span class="s2">&quot;positive or they should both be 0.&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DoubleSubMatrix</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span>
                                        <span class="n">col_start</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">)</span></div>


<span class="c1">################################################################################</span>
<span class="c1"># vector/matrix wrappers</span>
<span class="c1">################################################################################</span>


<span class="k">def</span> <span class="nf">_vector_wrapper</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a new vector instance by swapping contents.</span>

<span class="sd">    This function is used for converting `kaldi.matrix._kaldi_vector.Vector`</span>
<span class="sd">    (or `kaldi.matrix._kaldi_vector.DoubleVector`) instances into `Vector`</span>
<span class="sd">    (or `DoubleVector`) instances without copying the contents.</span>

<span class="sd">    This is a destructive operation. Contents of the input vector are moved to</span>
<span class="sd">    the newly contstructed vector by swapping data pointers.</span>

<span class="sd">    Args:</span>
<span class="sd">        vector (`Vector` or `DoubleVector`): The input vector.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Vector or DoubleVector: The new vector instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">Vector</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="p">()</span><span class="o">.</span><span class="n">swap_</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">_kaldi_vector</span><span class="o">.</span><span class="n">DoubleVector</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DoubleVector</span><span class="p">()</span><span class="o">.</span><span class="n">swap_</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unrecognized input type&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_matrix_wrapper</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a new matrix instance by swapping contents.</span>

<span class="sd">    This function is used for converting `kaldi.matrix._kaldi_matrix.Matrix`</span>
<span class="sd">    (or `kaldi.matrix._kaldi_matrix.DoubleMatrix`) instances into `Matrix`</span>
<span class="sd">    (or `DoubleMatrix`) instances without copying the contents.</span>

<span class="sd">    This is a destructive operation. Contents of the input matrix are moved to</span>
<span class="sd">    the newly contstructed matrix by swapping data pointers.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix (`Matrix` or `DoubleMatrix`): The input matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Matrix or DoubleMatrix: The new matrix instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">Matrix</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">()</span><span class="o">.</span><span class="n">swap_</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">_kaldi_matrix</span><span class="o">.</span><span class="n">DoubleMatrix</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DoubleMatrix</span><span class="p">()</span><span class="o">.</span><span class="n">swap_</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unrecognized input type&quot;</span><span class="p">)</span>


<span class="c1">################################################################################</span>

<span class="n">_exclude_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sys&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">]</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">()</span>
           <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span>
           <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;Base&#39;</span><span class="p">)</span>
           <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_exclude_list</span><span class="p">]</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2018, Doan Can, Victor Martinez.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.0.9',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>